// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for APIConfigurationKind.
const (
	Httprest APIConfigurationKind = "http/rest"
)

// Defines values for APIConfigurationVersion.
const (
	ApiPlatformWso2Comv1 APIConfigurationVersion = "api-platform.wso2.com/v1"
)

// Defines values for APIDetailResponseApiMetadataStatus.
const (
	APIDetailResponseApiMetadataStatusDeployed APIDetailResponseApiMetadataStatus = "deployed"
	APIDetailResponseApiMetadataStatusFailed   APIDetailResponseApiMetadataStatus = "failed"
	APIDetailResponseApiMetadataStatusPending  APIDetailResponseApiMetadataStatus = "pending"
)

// Defines values for APIListItemStatus.
const (
	APIListItemStatusDeployed APIListItemStatus = "deployed"
	APIListItemStatusFailed   APIListItemStatus = "failed"
	APIListItemStatusPending  APIListItemStatus = "pending"
)

// Defines values for CertificateResponseStatus.
const (
	Error   CertificateResponseStatus = "error"
	Success CertificateResponseStatus = "success"
)

// Defines values for ConfigDumpResponseApisMetadataStatus.
const (
	Deployed ConfigDumpResponseApisMetadataStatus = "deployed"
	Failed   ConfigDumpResponseApisMetadataStatus = "failed"
	Pending  ConfigDumpResponseApisMetadataStatus = "pending"
)

// Defines values for OperationMethod.
const (
	DELETE  OperationMethod = "DELETE"
	GET     OperationMethod = "GET"
	HEAD    OperationMethod = "HEAD"
	OPTIONS OperationMethod = "OPTIONS"
	PATCH   OperationMethod = "PATCH"
	POST    OperationMethod = "POST"
	PUT     OperationMethod = "PUT"
)

// APIConfigData defines model for APIConfigData.
type APIConfigData struct {
	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context"`

	// Name Human-readable API name (must be URL-friendly - only letters, numbers, spaces, hyphens, underscores, and dots allowed)
	Name string `json:"name"`

	// Operations List of HTTP operations/routes
	Operations []Operation `json:"operations"`

	// Policies List of API-level policies applied to all operations unless overridden
	Policies *[]Policy `json:"policies,omitempty"`

	// Upstreams List of backend service URLs
	Upstreams []Upstream `json:"upstreams"`

	// Version Semantic version of the API
	Version string `json:"version"`
}

// APIConfiguration defines model for APIConfiguration.
type APIConfiguration struct {
	// Kind API type
	Kind APIConfigurationKind `json:"kind"`
	Spec APIConfigData        `json:"spec"`

	// Version API specification version
	Version APIConfigurationVersion `json:"version"`
}

// APIConfigurationKind API type
type APIConfigurationKind string

// APIConfigurationVersion API specification version
type APIConfigurationVersion string

// APICreateResponse defines model for APICreateResponse.
type APICreateResponse struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id Unique identifier for the created API configuration
	Id      *openapi_types.UUID `json:"id,omitempty"`
	Message *string             `json:"message,omitempty"`
	Status  *string             `json:"status,omitempty"`
}

// APIDetailResponse defines model for APIDetailResponse.
type APIDetailResponse struct {
	Api *struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty"`
			Status     *APIDetailResponseApiMetadataStatus `json:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty"`
		} `json:"metadata,omitempty"`
	} `json:"api,omitempty"`
	Status *string `json:"status,omitempty"`
}

// APIDetailResponseApiMetadataStatus defines model for APIDetailResponse.Api.Metadata.Status.
type APIDetailResponseApiMetadataStatus string

// APIListItem defines model for APIListItem.
type APIListItem struct {
	Context   *string             `json:"context,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Status    *APIListItemStatus  `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	Version   *string             `json:"version,omitempty"`
}

// APIListItemStatus defines model for APIListItem.Status.
type APIListItemStatus string

// APIUpdateResponse defines model for APIUpdateResponse.
type APIUpdateResponse struct {
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Message   *string             `json:"message,omitempty"`
	Status    *string             `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// CertificateListResponse defines model for CertificateListResponse.
type CertificateListResponse struct {
	Certificates *[]CertificateResponse `json:"certificates,omitempty"`
	Status       *string                `json:"status,omitempty"`

	// TotalBytes Total bytes of all certificate files
	TotalBytes *int `json:"totalBytes,omitempty"`

	// TotalCount Total number of certificate files
	TotalCount *int `json:"totalCount,omitempty"`
}

// CertificateResponse defines model for CertificateResponse.
type CertificateResponse struct {
	// Count Number of certificates in the file
	Count *int `json:"count,omitempty"`

	// Id Unique identifier (UUID) for the certificate
	Id *string `json:"id,omitempty"`

	// Issuer Certificate issuer DN (for first cert if bundle)
	Issuer *string `json:"issuer,omitempty"`

	// Message Success or informational message
	Message *string `json:"message,omitempty"`

	// Name Name of the certificate
	Name *string `json:"name,omitempty"`

	// NotAfter Certificate expiration date (for first cert if bundle)
	NotAfter *time.Time                 `json:"notAfter,omitempty"`
	Status   *CertificateResponseStatus `json:"status,omitempty"`

	// Subject Certificate subject DN (for first cert if bundle)
	Subject *string `json:"subject,omitempty"`
}

// CertificateResponseStatus defines model for CertificateResponse.Status.
type CertificateResponseStatus string

// CertificateUploadRequest defines model for CertificateUploadRequest.
type CertificateUploadRequest struct {
	// Certificate PEM-encoded X.509 certificate(s). Can contain multiple certificates.
	Certificate string `json:"certificate"`

	// Name Unique name for the certificate. Must be unique across all certificates.
	Name string `json:"name"`
}

// ConfigDumpResponse defines model for ConfigDumpResponse.
type ConfigDumpResponse struct {
	// Apis All deployed API configurations
	Apis *[]struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                            `json:"created_at,omitempty"`
			DeployedAt *time.Time                            `json:"deployed_at,omitempty"`
			Status     *ConfigDumpResponseApisMetadataStatus `json:"status,omitempty"`
			UpdatedAt  *time.Time                            `json:"updated_at,omitempty"`
		} `json:"metadata,omitempty"`
	} `json:"apis,omitempty"`

	// Certificates All registered certificates
	Certificates *[]CertificateResponse `json:"certificates,omitempty"`

	// Policies All loaded policy definitions
	Policies *[]PolicyDefinition `json:"policies,omitempty"`

	// Statistics Summary statistics about the current configuration
	Statistics *struct {
		// TotalApis Total number of API configurations
		TotalApis *int `json:"totalApis,omitempty"`

		// TotalCertificateBytes Total bytes of all certificates
		TotalCertificateBytes *int `json:"totalCertificateBytes,omitempty"`

		// TotalCertificates Total number of certificates
		TotalCertificates *int `json:"totalCertificates,omitempty"`

		// TotalPolicies Total number of policy definitions
		TotalPolicies *int `json:"totalPolicies,omitempty"`
	} `json:"statistics,omitempty"`
	Status *string `json:"status,omitempty"`

	// Timestamp Timestamp when the config dump was generated
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// ConfigDumpResponseApisMetadataStatus defines model for ConfigDumpResponse.Apis.Metadata.Status.
type ConfigDumpResponseApisMetadataStatus string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors Detailed validation errors
	Errors *[]ValidationError `json:"errors,omitempty"`

	// Message High-level error description
	Message string `json:"message"`
	Status  string `json:"status"`
}

// Operation defines model for Operation.
type Operation struct {
	// Method HTTP method
	Method OperationMethod `json:"method"`

	// Path Route path with optional {param} placeholders
	Path string `json:"path"`

	// Policies List of policies applied only to this operation (overrides or adds to API-level policies)
	Policies *[]Policy `json:"policies,omitempty"`
}

// OperationMethod HTTP method
type OperationMethod string

// Policy defines model for Policy.
type Policy struct {
	// ExecutionCondition Expression controlling conditional execution of the policy
	ExecutionCondition *string `json:"executionCondition,omitempty"`

	// Name Name of the policy
	Name string `json:"name"`

	// Params Arbitrary parameters for the policy (free-form key/value structure)
	Params *map[string]interface{} `json:"params,omitempty"`

	// Version Semantic version of the policy
	Version string `json:"version"`
}

// PolicyDefinition defines model for PolicyDefinition.
type PolicyDefinition struct {
	// Description Human readable description of the policy's purpose
	Description *string `json:"description,omitempty"`

	// Name Unique policy name
	Name string `json:"name"`

	// ParametersSchema JSON Schema describing the parameters accepted by this policy. This itself is a JSON Schema document.
	ParametersSchema *map[string]interface{} `json:"parametersSchema,omitempty"`

	// Version Semantic version of the policy definition
	Version string `json:"version"`
}

// PolicyListResponse defines model for PolicyListResponse.
type PolicyListResponse struct {
	Count    *int                `json:"count,omitempty"`
	Policies *[]PolicyDefinition `json:"policies,omitempty"`
	Status   *string             `json:"status,omitempty"`
}

// Upstream defines model for Upstream.
type Upstream struct {
	// Url Backend service URL (may include path prefix like /api/v2)
	Url string `json:"url"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field that failed validation
	Field *string `json:"field,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`
}

// CreateAPIJSONRequestBody defines body for CreateAPI for application/json ContentType.
type CreateAPIJSONRequestBody = APIConfiguration

// UpdateAPIJSONRequestBody defines body for UpdateAPI for application/json ContentType.
type UpdateAPIJSONRequestBody = APIConfiguration

// UploadCertificateJSONRequestBody defines body for UploadCertificate for application/json ContentType.
type UploadCertificateJSONRequestBody = CertificateUploadRequest

// Getter for additional properties for PolicyDefinition_Flows. Returns the specified
// element and whether it was found
func (a PolicyDefinition_Flows) Get(fieldName string) (value PolicyFlowRequirements, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PolicyDefinition_Flows
func (a *PolicyDefinition_Flows) Set(fieldName string, value PolicyFlowRequirements) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]PolicyFlowRequirements)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PolicyDefinition_Flows to handle AdditionalProperties
func (a *PolicyDefinition_Flows) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["request"]; found {
		err = json.Unmarshal(raw, &a.Request)
		if err != nil {
			return fmt.Errorf("error reading 'request': %w", err)
		}
		delete(object, "request")
	}

	if raw, found := object["response"]; found {
		err = json.Unmarshal(raw, &a.Response)
		if err != nil {
			return fmt.Errorf("error reading 'response': %w", err)
		}
		delete(object, "response")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]PolicyFlowRequirements)
		for fieldName, fieldBuf := range object {
			var fieldVal PolicyFlowRequirements
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PolicyDefinition_Flows to handle AdditionalProperties
func (a PolicyDefinition_Flows) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Request != nil {
		object["request"], err = json.Marshal(a.Request)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'request': %w", err)
		}
	}

	if a.Response != nil {
		object["response"], err = json.Marshal(a.Response)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'response': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all API configurations
	// (GET /apis)
	ListAPIs(c *gin.Context)
	// Create a new API configuration
	// (POST /apis)
	CreateAPI(c *gin.Context)
	// Delete an API configuration
	// (DELETE /apis/{name}/{version})
	DeleteAPI(c *gin.Context, name string, version string)
	// Get API configuration by name and version
	// (GET /apis/{name}/{version})
	GetAPIByNameVersion(c *gin.Context, name string, version string)
	// Update an existing API configuration
	// (PUT /apis/{name}/{version})
	UpdateAPI(c *gin.Context, name string, version string)
	// List all custom certificates
	// (GET /certificates)
	ListCertificates(c *gin.Context)
	// Upload a new certificate
	// (POST /certificates)
	UploadCertificate(c *gin.Context)
	// Manually reload certificates
	// (POST /certificates/reload)
	ReloadCertificates(c *gin.Context)
	// Delete a certificate
	// (DELETE /certificates/{id})
	DeleteCertificate(c *gin.Context, id string)
	// Dump current configuration state
	// (GET /config_dump)
	GetConfigDump(c *gin.Context)
	// Health check endpoint
	// (GET /health)
	HealthCheck(c *gin.Context)
	// List all registered policy definitions
	// (GET /policies)
	ListPolicies(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListAPIs operation middleware
func (siw *ServerInterfaceWrapper) ListAPIs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAPIs(c)
}

// CreateAPI operation middleware
func (siw *ServerInterfaceWrapper) CreateAPI(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateAPI(c)
}

// DeleteAPI operation middleware
func (siw *ServerInterfaceWrapper) DeleteAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAPI(c, name, version)
}

// GetAPIByNameVersion operation middleware
func (siw *ServerInterfaceWrapper) GetAPIByNameVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAPIByNameVersion(c, name, version)
}

// UpdateAPI operation middleware
func (siw *ServerInterfaceWrapper) UpdateAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateAPI(c, name, version)
}

// ListCertificates operation middleware
func (siw *ServerInterfaceWrapper) ListCertificates(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListCertificates(c)
}

// UploadCertificate operation middleware
func (siw *ServerInterfaceWrapper) UploadCertificate(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadCertificate(c)
}

// ReloadCertificates operation middleware
func (siw *ServerInterfaceWrapper) ReloadCertificates(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ReloadCertificates(c)
}

// DeleteCertificate operation middleware
func (siw *ServerInterfaceWrapper) DeleteCertificate(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteCertificate(c, id)
}

// GetConfigDump operation middleware
func (siw *ServerInterfaceWrapper) GetConfigDump(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConfigDump(c)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HealthCheck(c)
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPolicies(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/apis", wrapper.ListAPIs)
	router.POST(options.BaseURL+"/apis", wrapper.CreateAPI)
	router.DELETE(options.BaseURL+"/apis/:name/:version", wrapper.DeleteAPI)
	router.GET(options.BaseURL+"/apis/:name/:version", wrapper.GetAPIByNameVersion)
	router.PUT(options.BaseURL+"/apis/:name/:version", wrapper.UpdateAPI)
	router.GET(options.BaseURL+"/certificates", wrapper.ListCertificates)
	router.POST(options.BaseURL+"/certificates", wrapper.UploadCertificate)
	router.POST(options.BaseURL+"/certificates/reload", wrapper.ReloadCertificates)
	router.DELETE(options.BaseURL+"/certificates/:id", wrapper.DeleteCertificate)
	router.GET(options.BaseURL+"/config_dump", wrapper.GetConfigDump)
	router.GET(options.BaseURL+"/health", wrapper.HealthCheck)
	router.GET(options.BaseURL+"/policies", wrapper.ListPolicies)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//+6YmyPX2MAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
