// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for APIConfigurationKind.
const (
	Httprest APIConfigurationKind = "http/rest"
)

// Defines values for APIConfigurationVersion.
const (
	ApiPlatformWso2Comv1 APIConfigurationVersion = "api-platform.wso2.com/v1"
)

// Defines values for APIDetailResponseApiMetadataStatus.
const (
	APIDetailResponseApiMetadataStatusDeployed APIDetailResponseApiMetadataStatus = "deployed"
	APIDetailResponseApiMetadataStatusFailed   APIDetailResponseApiMetadataStatus = "failed"
	APIDetailResponseApiMetadataStatusPending  APIDetailResponseApiMetadataStatus = "pending"
)

// Defines values for APIListItemStatus.
const (
	APIListItemStatusDeployed APIListItemStatus = "deployed"
	APIListItemStatusFailed   APIListItemStatus = "failed"
	APIListItemStatusPending  APIListItemStatus = "pending"
)

// Defines values for CertificateResponseStatus.
const (
	Error   CertificateResponseStatus = "error"
	Success CertificateResponseStatus = "success"
)

// Defines values for ConfigDumpResponseApisMetadataStatus.
const (
	ConfigDumpResponseApisMetadataStatusDeployed ConfigDumpResponseApisMetadataStatus = "deployed"
	ConfigDumpResponseApisMetadataStatusFailed   ConfigDumpResponseApisMetadataStatus = "failed"
	ConfigDumpResponseApisMetadataStatusPending  ConfigDumpResponseApisMetadataStatus = "pending"
)

// Defines values for MCPDetailResponseMcpMetadataStatus.
const (
	MCPDetailResponseMcpMetadataStatusDeployed MCPDetailResponseMcpMetadataStatus = "deployed"
	MCPDetailResponseMcpMetadataStatusFailed   MCPDetailResponseMcpMetadataStatus = "failed"
	MCPDetailResponseMcpMetadataStatusPending  MCPDetailResponseMcpMetadataStatus = "pending"
)

// Defines values for MCPProxyConfigurationKind.
const (
	Mcp MCPProxyConfigurationKind = "mcp"
)

// Defines values for MCPProxyConfigurationVersion.
const (
	AiApiPlatformWso2Comv1 MCPProxyConfigurationVersion = "ai.api-platform.wso2.com/v1"
)

// Defines values for MCPProxyListItemStatus.
const (
	Deployed MCPProxyListItemStatus = "deployed"
	Failed   MCPProxyListItemStatus = "failed"
	Pending  MCPProxyListItemStatus = "pending"
)

// Defines values for OperationMethod.
const (
	DELETE  OperationMethod = "DELETE"
	GET     OperationMethod = "GET"
	HEAD    OperationMethod = "HEAD"
	OPTIONS OperationMethod = "OPTIONS"
	PATCH   OperationMethod = "PATCH"
	POST    OperationMethod = "POST"
	PUT     OperationMethod = "PUT"
)

// APIConfigData defines model for APIConfigData.
type APIConfigData struct {
	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context" yaml:"context"`

	// Name Human-readable API name (must be URL-friendly - only letters, numbers, spaces, hyphens, underscores, and dots allowed)
	Name string `json:"name" yaml:"name"`

	// Operations List of HTTP operations/routes
	Operations []Operation `json:"operations" yaml:"operations"`

	// Policies List of API-level policies applied to all operations unless overridden
	Policies *[]Policy `json:"policies,omitempty" yaml:"policies,omitempty"`

	// Upstreams List of backend service URLs
	Upstreams []Upstream `json:"upstreams" yaml:"upstreams"`

	// Version Semantic version of the API
	Version string `json:"version" yaml:"version"`
}

// APIConfiguration defines model for APIConfiguration.
type APIConfiguration struct {
	// Kind API type
	Kind APIConfigurationKind `json:"kind" yaml:"kind"`
	Spec APIConfigData        `json:"spec" yaml:"spec"`

	// Version API specification version
	Version APIConfigurationVersion `json:"version" yaml:"version"`
}

// APIConfigurationKind API type
type APIConfigurationKind string

// APIConfigurationVersion API specification version
type APIConfigurationVersion string

// APICreateResponse defines model for APICreateResponse.
type APICreateResponse struct {
	CreatedAt *time.Time `json:"created_at,omitempty" yaml:"created_at,omitempty"`

	// Id Unique identifier for the created API configuration
	Id      *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Message *string             `json:"message,omitempty" yaml:"message,omitempty"`
	Status  *string             `json:"status,omitempty" yaml:"status,omitempty"`
}

// APIDetailResponse defines model for APIDetailResponse.
type APIDetailResponse struct {
	Api *struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty" yaml:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty" yaml:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty" yaml:"deployed_at,omitempty"`
			Status     *APIDetailResponseApiMetadataStatus `json:"status,omitempty" yaml:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
		} `json:"metadata,omitempty" yaml:"metadata,omitempty"`
	} `json:"api,omitempty" yaml:"api,omitempty"`
	Status *string `json:"status,omitempty" yaml:"status,omitempty"`
}

// APIDetailResponseApiMetadataStatus defines model for APIDetailResponse.Api.Metadata.Status.
type APIDetailResponseApiMetadataStatus string

// APIListItem defines model for APIListItem.
type APIListItem struct {
	Context   *string             `json:"context,omitempty" yaml:"context,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty" yaml:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Name      *string             `json:"name,omitempty" yaml:"name,omitempty"`
	Status    *APIListItemStatus  `json:"status,omitempty" yaml:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
	Version   *string             `json:"version,omitempty" yaml:"version,omitempty"`
}

// APIListItemStatus defines model for APIListItem.Status.
type APIListItemStatus string

// APIUpdateResponse defines model for APIUpdateResponse.
type APIUpdateResponse struct {
	Id        *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Message   *string             `json:"message,omitempty" yaml:"message,omitempty"`
	Status    *string             `json:"status,omitempty" yaml:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
}

// CertificateListResponse defines model for CertificateListResponse.
type CertificateListResponse struct {
	Certificates *[]CertificateResponse `json:"certificates,omitempty" yaml:"certificates,omitempty"`
	Status       *string                `json:"status,omitempty" yaml:"status,omitempty"`

	// TotalBytes Total bytes of all certificate files
	TotalBytes *int `json:"totalBytes,omitempty" yaml:"totalBytes,omitempty"`

	// TotalCount Total number of certificate files
	TotalCount *int `json:"totalCount,omitempty" yaml:"totalCount,omitempty"`
}

// CertificateResponse defines model for CertificateResponse.
type CertificateResponse struct {
	// Count Number of certificates in the file
	Count *int `json:"count,omitempty" yaml:"count,omitempty"`

	// Id Unique identifier (UUID) for the certificate
	Id *string `json:"id,omitempty" yaml:"id,omitempty"`

	// Issuer Certificate issuer DN (for first cert if bundle)
	Issuer *string `json:"issuer,omitempty" yaml:"issuer,omitempty"`

	// Message Success or informational message
	Message *string `json:"message,omitempty" yaml:"message,omitempty"`

	// Name Name of the certificate
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`

	// NotAfter Certificate expiration date (for first cert if bundle)
	NotAfter *time.Time                 `json:"notAfter,omitempty" yaml:"notAfter,omitempty"`
	Status   *CertificateResponseStatus `json:"status,omitempty" yaml:"status,omitempty"`

	// Subject Certificate subject DN (for first cert if bundle)
	Subject *string `json:"subject,omitempty" yaml:"subject,omitempty"`
}

// CertificateResponseStatus defines model for CertificateResponse.Status.
type CertificateResponseStatus string

// CertificateUploadRequest defines model for CertificateUploadRequest.
type CertificateUploadRequest struct {
	// Certificate PEM-encoded X.509 certificate(s). Can contain multiple certificates.
	Certificate string `json:"certificate" yaml:"certificate"`

	// Name Unique name for the certificate. Must be unique across all certificates.
	Name string `json:"name" yaml:"name"`
}

// ConfigDumpResponse defines model for ConfigDumpResponse.
type ConfigDumpResponse struct {
	// Apis All deployed API configurations
	Apis *[]struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty" yaml:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                            `json:"created_at,omitempty" yaml:"created_at,omitempty"`
			DeployedAt *time.Time                            `json:"deployed_at,omitempty" yaml:"deployed_at,omitempty"`
			Status     *ConfigDumpResponseApisMetadataStatus `json:"status,omitempty" yaml:"status,omitempty"`
			UpdatedAt  *time.Time                            `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
		} `json:"metadata,omitempty" yaml:"metadata,omitempty"`
	} `json:"apis,omitempty" yaml:"apis,omitempty"`

	// Certificates All registered certificates
	Certificates *[]CertificateResponse `json:"certificates,omitempty" yaml:"certificates,omitempty"`

	// Policies All loaded policy definitions
	Policies *[]PolicyDefinition `json:"policies,omitempty" yaml:"policies,omitempty"`

	// Statistics Summary statistics about the current configuration
	Statistics *struct {
		// TotalApis Total number of API configurations
		TotalApis *int `json:"totalApis,omitempty" yaml:"totalApis,omitempty"`

		// TotalCertificateBytes Total bytes of all certificates
		TotalCertificateBytes *int `json:"totalCertificateBytes,omitempty" yaml:"totalCertificateBytes,omitempty"`

		// TotalCertificates Total number of certificates
		TotalCertificates *int `json:"totalCertificates,omitempty" yaml:"totalCertificates,omitempty"`

		// TotalPolicies Total number of policy definitions
		TotalPolicies *int `json:"totalPolicies,omitempty" yaml:"totalPolicies,omitempty"`
	} `json:"statistics,omitempty" yaml:"statistics,omitempty"`
	Status *string `json:"status,omitempty" yaml:"status,omitempty"`

	// Timestamp Timestamp when the config dump was generated
	Timestamp *time.Time `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

// ConfigDumpResponseApisMetadataStatus defines model for ConfigDumpResponse.Apis.Metadata.Status.
type ConfigDumpResponseApisMetadataStatus string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors Detailed validation errors
	Errors *[]ValidationError `json:"errors,omitempty" yaml:"errors,omitempty"`

	// Message High-level error description
	Message string `json:"message" yaml:"message"`
	Status  string `json:"status" yaml:"status"`
}

// MCPDetailResponse defines model for MCPDetailResponse.
type MCPDetailResponse struct {
	Mcp *struct {
		Configuration *MCPProxyConfiguration `json:"configuration,omitempty" yaml:"configuration,omitempty"`
		Id            *openapi_types.UUID    `json:"id,omitempty" yaml:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty" yaml:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty" yaml:"deployed_at,omitempty"`
			Status     *MCPDetailResponseMcpMetadataStatus `json:"status,omitempty" yaml:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
		} `json:"metadata,omitempty" yaml:"metadata,omitempty"`
	} `json:"mcp,omitempty" yaml:"mcp,omitempty"`
	Status *string `json:"status,omitempty" yaml:"status,omitempty"`
}

// MCPDetailResponseMcpMetadataStatus defines model for MCPDetailResponse.Mcp.Metadata.Status.
type MCPDetailResponseMcpMetadataStatus string

// MCPPrompt defines model for MCPPrompt.
type MCPPrompt struct {
	// Arguments Optional list of arguments for customization
	Arguments *[]struct {
		// Description Description of the argument
		Description *string `json:"description,omitempty" yaml:"description,omitempty"`

		// Name Name of the argument
		Name string `json:"name" yaml:"name"`

		// Required Whether the argument is required
		Required *bool `json:"required,omitempty" yaml:"required,omitempty"`

		// Title Optional human-readable title of the argument
		Title *string `json:"title,omitempty" yaml:"title,omitempty"`
	} `json:"arguments,omitempty" yaml:"arguments,omitempty"`

	// Description Optional human-readable description
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// Name Unique identifier for the prompt
	Name string `json:"name" yaml:"name"`

	// Title Optional human-readable name of the prompt for display purposes
	Title *string `json:"title,omitempty" yaml:"title,omitempty"`
}

// MCPProxyConfigData defines model for MCPProxyConfigData.
type MCPProxyConfigData struct {
	// Context MCP Proxy context path
	Context string `json:"context" yaml:"context"`

	// Name Human-readable MCP Proxy name
	Name      string         `json:"name" yaml:"name"`
	Prompts   *[]MCPPrompt   `json:"prompts,omitempty" yaml:"prompts,omitempty"`
	Resources *[]MCPResource `json:"resources,omitempty" yaml:"resources,omitempty"`

	// SpecVersion MCP specification version
	SpecVersion *string    `json:"specVersion,omitempty" yaml:"specVersion,omitempty"`
	Tools       *[]MCPTool `json:"tools,omitempty" yaml:"tools,omitempty"`

	// Upstreams List of backend service URLs
	Upstreams []Upstream `json:"upstreams" yaml:"upstreams"`

	// Version MCP Proxy version
	Version string `json:"version" yaml:"version"`
}

// MCPProxyConfiguration defines model for MCPProxyConfiguration.
type MCPProxyConfiguration struct {
	// Kind MCP Proxy type
	Kind MCPProxyConfigurationKind `json:"kind" yaml:"kind"`
	Spec MCPProxyConfigData        `json:"spec" yaml:"spec"`

	// Version MCP Proxy specification version
	Version MCPProxyConfigurationVersion `json:"version" yaml:"version"`
}

// MCPProxyConfigurationKind MCP Proxy type
type MCPProxyConfigurationKind string

// MCPProxyConfigurationVersion MCP Proxy specification version
type MCPProxyConfigurationVersion string

// MCPProxyListItem defines model for MCPProxyListItem.
type MCPProxyListItem struct {
	Context     *string                 `json:"context,omitempty" yaml:"context,omitempty"`
	CreatedAt   *time.Time              `json:"created_at,omitempty" yaml:"created_at,omitempty"`
	Id          *openapi_types.UUID     `json:"id,omitempty" yaml:"id,omitempty"`
	Name        *string                 `json:"name,omitempty" yaml:"name,omitempty"`
	SpecVersion *string                 `json:"specVersion,omitempty" yaml:"specVersion,omitempty"`
	Status      *MCPProxyListItemStatus `json:"status,omitempty" yaml:"status,omitempty"`
	UpdatedAt   *time.Time              `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
	Version     *string                 `json:"version,omitempty" yaml:"version,omitempty"`
}

// MCPProxyListItemStatus defines model for MCPProxyListItem.Status.
type MCPProxyListItemStatus string

// MCPResource defines model for MCPResource.
type MCPResource struct {
	// Description Optional description
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// MimeType Optional MIME type
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty"`

	// Name The name of the resource
	Name string `json:"name" yaml:"name"`

	// Size Optional size in bytes
	Size *int `json:"size,omitempty" yaml:"size,omitempty"`

	// Title Optional human-readable name of the resource for display purposes
	Title *string `json:"title,omitempty" yaml:"title,omitempty"`

	// Uri Unique identifier for the resource
	Uri string `json:"uri" yaml:"uri"`
}

// MCPTool defines model for MCPTool.
type MCPTool struct {
	// Description Human-readable description of functionality
	Description string `json:"description" yaml:"description"`

	// InputSchema JSON Schema defining expected parameters
	InputSchema string `json:"inputSchema" yaml:"inputSchema"`

	// Name Unique identifier for the tool
	Name string `json:"name" yaml:"name"`

	// OutputSchema Optional JSON Schema defining expected output structure
	OutputSchema *string `json:"outputSchema,omitempty" yaml:"outputSchema,omitempty"`

	// Title Optional human-readable name of the tool for display purposes.
	Title *string `json:"title,omitempty" yaml:"title,omitempty"`
}

// Operation defines model for Operation.
type Operation struct {
	// Method HTTP method
	Method OperationMethod `json:"method" yaml:"method"`

	// Path Route path with optional {param} placeholders
	Path string `json:"path" yaml:"path"`

	// Policies List of policies applied only to this operation (overrides or adds to API-level policies)
	Policies *[]Policy `json:"policies,omitempty" yaml:"policies,omitempty"`
}

// OperationMethod HTTP method
type OperationMethod string

// Policy defines model for Policy.
type Policy struct {
	// ExecutionCondition Expression controlling conditional execution of the policy
	ExecutionCondition *string `json:"executionCondition,omitempty" yaml:"executionCondition,omitempty"`

	// Name Name of the policy
	Name string `json:"name" yaml:"name"`

	// Params Arbitrary parameters for the policy (free-form key/value structure)
	Params *map[string]interface{} `json:"params,omitempty" yaml:"params,omitempty"`

	// Version Semantic version of the policy
	Version string `json:"version" yaml:"version"`
}

// PolicyDefinition defines model for PolicyDefinition.
type PolicyDefinition struct {
	// Description Human readable description of the policy's purpose
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// Name Unique policy name
	Name string `json:"name" yaml:"name"`

	// ParametersSchema JSON Schema describing the parameters accepted by this policy. This itself is a JSON Schema document.
	ParametersSchema *map[string]interface{} `json:"parametersSchema,omitempty" yaml:"parametersSchema,omitempty"`

	// Version Semantic version of the policy definition
	Version string `json:"version" yaml:"version"`
}

// PolicyListResponse defines model for PolicyListResponse.
type PolicyListResponse struct {
	Count    *int                `json:"count,omitempty" yaml:"count,omitempty"`
	Policies *[]PolicyDefinition `json:"policies,omitempty" yaml:"policies,omitempty"`
	Status   *string             `json:"status,omitempty" yaml:"status,omitempty"`
}

// Upstream defines model for Upstream.
type Upstream struct {
	// Url Backend service URL (may include path prefix like /api/v2)
	Url string `json:"url" yaml:"url"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field that failed validation
	Field *string `json:"field,omitempty" yaml:"field,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty" yaml:"message,omitempty"`
}

// CreateAPIJSONRequestBody defines body for CreateAPI for application/json ContentType.
type CreateAPIJSONRequestBody = APIConfiguration

// UpdateAPIJSONRequestBody defines body for UpdateAPI for application/json ContentType.
type UpdateAPIJSONRequestBody = APIConfiguration

// UploadCertificateJSONRequestBody defines body for UploadCertificate for application/json ContentType.
type UploadCertificateJSONRequestBody = CertificateUploadRequest

// CreateMCPProxyJSONRequestBody defines body for CreateMCPProxy for application/json ContentType.
type CreateMCPProxyJSONRequestBody = MCPProxyConfiguration

// UpdateMCPProxyJSONRequestBody defines body for UpdateMCPProxy for application/json ContentType.
type UpdateMCPProxyJSONRequestBody = MCPProxyConfiguration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all API configurations
	// (GET /apis)
	ListAPIs(c *gin.Context)
	// Create a new API configuration
	// (POST /apis)
	CreateAPI(c *gin.Context)
	// Delete an API configuration
	// (DELETE /apis/{name}/{version})
	DeleteAPI(c *gin.Context, name string, version string)
	// Get API configuration by name and version
	// (GET /apis/{name}/{version})
	GetAPIByNameVersion(c *gin.Context, name string, version string)
	// Update an existing API configuration
	// (PUT /apis/{name}/{version})
	UpdateAPI(c *gin.Context, name string, version string)
	// List all custom certificates
	// (GET /certificates)
	ListCertificates(c *gin.Context)
	// Upload a new certificate
	// (POST /certificates)
	UploadCertificate(c *gin.Context)
	// Manually reload certificates
	// (POST /certificates/reload)
	ReloadCertificates(c *gin.Context)
	// Delete a certificate
	// (DELETE /certificates/{id})
	DeleteCertificate(c *gin.Context, id string)
	// Dump current configuration state
	// (GET /config_dump)
	GetConfigDump(c *gin.Context)
	// Health check endpoint
	// (GET /health)
	HealthCheck(c *gin.Context)
	// List all MCP Proxy configurations
	// (GET /mcp-proxies)
	ListMCPProxies(c *gin.Context)
	// Create a new MCP Proxy configuration
	// (POST /mcp-proxies)
	CreateMCPProxy(c *gin.Context)
	// Delete an MCP Proxy configuration
	// (DELETE /mcp-proxies/{name}/{version})
	DeleteMCPProxy(c *gin.Context, name string, version string)
	// Get MCP Proxy configuration by name and version
	// (GET /mcp-proxies/{name}/{version})
	GetMCPProxyByNameVersion(c *gin.Context, name string, version string)
	// Update an existing MCP Proxy configuration
	// (PUT /mcp-proxies/{name}/{version})
	UpdateMCPProxy(c *gin.Context, name string, version string)
	// List all registered policy definitions
	// (GET /policies)
	ListPolicies(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListAPIs operation middleware
func (siw *ServerInterfaceWrapper) ListAPIs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAPIs(c)
}

// CreateAPI operation middleware
func (siw *ServerInterfaceWrapper) CreateAPI(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateAPI(c)
}

// DeleteAPI operation middleware
func (siw *ServerInterfaceWrapper) DeleteAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAPI(c, name, version)
}

// GetAPIByNameVersion operation middleware
func (siw *ServerInterfaceWrapper) GetAPIByNameVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAPIByNameVersion(c, name, version)
}

// UpdateAPI operation middleware
func (siw *ServerInterfaceWrapper) UpdateAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateAPI(c, name, version)
}

// ListCertificates operation middleware
func (siw *ServerInterfaceWrapper) ListCertificates(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListCertificates(c)
}

// UploadCertificate operation middleware
func (siw *ServerInterfaceWrapper) UploadCertificate(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadCertificate(c)
}

// ReloadCertificates operation middleware
func (siw *ServerInterfaceWrapper) ReloadCertificates(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ReloadCertificates(c)
}

// DeleteCertificate operation middleware
func (siw *ServerInterfaceWrapper) DeleteCertificate(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteCertificate(c, id)
}

// GetConfigDump operation middleware
func (siw *ServerInterfaceWrapper) GetConfigDump(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConfigDump(c)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HealthCheck(c)
}

// ListMCPProxies operation middleware
func (siw *ServerInterfaceWrapper) ListMCPProxies(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListMCPProxies(c)
}

// CreateMCPProxy operation middleware
func (siw *ServerInterfaceWrapper) CreateMCPProxy(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateMCPProxy(c)
}

// DeleteMCPProxy operation middleware
func (siw *ServerInterfaceWrapper) DeleteMCPProxy(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteMCPProxy(c, name, version)
}

// GetMCPProxyByNameVersion operation middleware
func (siw *ServerInterfaceWrapper) GetMCPProxyByNameVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMCPProxyByNameVersion(c, name, version)
}

// UpdateMCPProxy operation middleware
func (siw *ServerInterfaceWrapper) UpdateMCPProxy(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateMCPProxy(c, name, version)
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPolicies(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/apis", wrapper.ListAPIs)
	router.POST(options.BaseURL+"/apis", wrapper.CreateAPI)
	router.DELETE(options.BaseURL+"/apis/:name/:version", wrapper.DeleteAPI)
	router.GET(options.BaseURL+"/apis/:name/:version", wrapper.GetAPIByNameVersion)
	router.PUT(options.BaseURL+"/apis/:name/:version", wrapper.UpdateAPI)
	router.GET(options.BaseURL+"/certificates", wrapper.ListCertificates)
	router.POST(options.BaseURL+"/certificates", wrapper.UploadCertificate)
	router.POST(options.BaseURL+"/certificates/reload", wrapper.ReloadCertificates)
	router.DELETE(options.BaseURL+"/certificates/:id", wrapper.DeleteCertificate)
	router.GET(options.BaseURL+"/config_dump", wrapper.GetConfigDump)
	router.GET(options.BaseURL+"/health", wrapper.HealthCheck)
	router.GET(options.BaseURL+"/mcp-proxies", wrapper.ListMCPProxies)
	router.POST(options.BaseURL+"/mcp-proxies", wrapper.CreateMCPProxy)
	router.DELETE(options.BaseURL+"/mcp-proxies/:name/:version", wrapper.DeleteMCPProxy)
	router.GET(options.BaseURL+"/mcp-proxies/:name/:version", wrapper.GetMCPProxyByNameVersion)
	router.PUT(options.BaseURL+"/mcp-proxies/:name/:version", wrapper.UpdateMCPProxy)
	router.GET(options.BaseURL+"/policies", wrapper.ListPolicies)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xde1cbObL/Krp995xNMn7BQHbDPfsHMUziTUhYDNm5G3MzcnfZ1qZb6pHUgCeH736P",
	"Hv1W220DGTKb+WMC3WqpJJWqfvVQ8cXzWRQzClQK7+CLJ/wFRFj/eHg6GjI6I/MjLLF6EHMWA5cE9Guf",
	"UQk3Uv0YgPA5iSVh1DvwXmIBKMZygWaMIxyG6PB0hDhLJAj0JEqEREJiLtE1kQvU7yDKkOSYhITOkQix",
	"WDz1Oh7c4CgOwTvw+teA5QK41/EifPMW6FwuvIPdwaDjRYSmv+90vBhLCVyR8H+TSf8j7v522P3XoPvi",
	"02TSnUz6l88+queXf/I6nlzGqmshOaFz77bjURxBfSqvkwjTLgcc4GkIeh6qoZ3FFNDF2dvujBOgQbhE",
	"XcRouEQhKDJEB9EkmuofRIx9EB20WMYLoKKDEhoAFz7j6immAQqYFGqp2DUE5dnbyXdxTMoLsLNyAfLZ",
	"TybdT5NJD13+4Jy42lKspivq039LhERshl6fn5+ivGHf7KXX8YiESH/3Jw4z78D7737OTX3LSv336Ydq",
	"uIjQkfloJyMGc46X6mXMQuJb9nJTcng66oZwBSFK2yIcxyGBAEmmeS0nEyU0BCEQuwLOSRAAbUvxqepb",
	"U1SlMImF5ICjFSROsf8ZaIAE8CviaxZpvVQXtvu1K3UFXOhhq1SMIcJUEh/ZFooiudCsW2Krq53ewCtx",
	"zNVkEvwwmfTUPw5Oue14HH5NCIfAO/hozktORycTB8U1KnHXZdYlm/4bfKmmkYmYxHJITcp8JjSoz1Id",
	"RN1ZxwOaRIqghZRxn4OQaqB8nvljB++LGPx1W1KWgquWXhGleiQz4uvZoHx1UipxTLpxiOWM8ah3Ldhu",
	"z2dR/2qnTHRjq3W7kg+o183OsGnlOWAJZyBiRgU4BLx+H3zCWsbn1O0Odve7O4Puzs75zuDgx8HBYPAv",
	"r+MpYlVTL8ASupJo/qgtOXHs5gUlvyaASABUkhkBrhWH4lpLgha8folRisu1vz+Av+4NBl3YfTHt7u0E",
	"e138l53n3b2958/39/f2BoPBoEhgkpDARVsEQuA5lGdbGzojSiS+D0LMkjBcOrlLYpmIcm/2G+dGuvbo",
	"CCQmYfMeKa3g0szlI9WKv5NcSJtNeogFljhwg4mH4LUA4pAtW/W6377XwrbaQx0DDdTLfETVGSYhBOVz",
	"XXhd6zaJg/tegTpPubjsPthU6T6lrFaiRCeiq63DA0qd+2foFDU2wbVvmHlKiq6GG9qxxYUmq1l6PZyc",
	"aSXI7ardryBvtxk7B3v7dzrJHW+o1lFDDVDHb4UezxuaVW+DRAu9Zz078PCGSyOZxOHLpXRB/HP1Dk3V",
	"SwVaFZYvUI5mJNQmRzbO7u7O/osX2SCESpgDz0YZsoTKplGMZaaGWTnEj/Xe1+zEil1w0/PORYlAhGr8",
	"oygqErTjmm47SPXk4mJ09DRHVvlo22CpuoQVIgFeJ6SwNsi0QUfv0BNFxoxwITUhiMzQNKFBCGXbd/ju",
	"bydLNDzsvFf/vudzTMlv+ux2hn+7GK85+hXDyHAlYhwRas4cYRSHKP2iNHCB6iQOGQ4g0Hb6+GjcWmy4",
	"XQrvcASpUda0CdGy6ydCsqjrY2fPTB7O5LrlhpuYWEmnCG676LuD3efdnZ3u7nM0eH4w+MvB7vM7YKNc",
	"GADnjJdV2gpJIRJzvFbO0DZ6SI5ac94vNHOcwa+JMjFXid76TE6PT7pAfaZ46+fe/uBFkR+eiKc9NMRU",
	"qSyJCUVREkoShyWmEb3S5Lrqv5fHr0bv0PD47Hz002h4eH6sn07oyWh09PP5cHj4+Z/zw+vRy8P56O+H",
	"b94OLl79EJ29kf8+ORy8Go5/fTUeTX88+sfxy+H1xeHJ8cXN8LfDv7+cv/swob1eb0J1b8fvjhwjtD8D",
	"VjppV5pDIPXQiXWvJaYh9jkToqoSKrOvHJotPGW9T93LFq6P8qnVM3RZ2NZrkETxSvPNoQkPwxClaK9u",
	"+pacSd8Nv++G37aGXxXLVXFinSk5zImQwCEoncO23s2WmLLZC6xosMpYN1qiAGaEktqxWO/cPco+bIK1",
	"REjiCxeQiCLMlyhvg/CUJdJIsYRzoLLmrCozvQaoh86zX8WnzuOfMcl+M/zN13orvL0R1F7JOCsQd3mQ",
	"xv5PGxmi2reTKzaF85vaNCQCIXEUO8hLX6HrBRhEb/YSBYl6iAWaAwWuzn8Vg+0bDHYPZ7/jHSvo1ayF",
	"NDJzrK5xPkKArnBIAoMkbduWZ+1D9qEmwXXUGgH7azJf2FiPHhQVX5cwXcmoL9BqJXFLi97g03XK336Z",
	"0+1S/SfD03WO28iP76i/T4anp5zdLB+9Et/p7u7dvxIv9vrYlfhWK/CVvLeGjaLYYb1gPk+iNDGgfDjf",
	"x9Z6Dm3UM2urAb0B4tayasarpT7r0if7LbWX00G2s7ZXfZ0f8WoP/1yAXAAv9YCIQNkXWW9TxkLABk8Q",
	"GcKKVVuU8wp08/VkukKwly2A3cplbqKpLG03M+wckbzY8JhTf260VrSwo6ZTPUZARBziJYoTHjMBYvvV",
	"K8vVDXNfToanSH+NbBOdCFNOZ4n8uBurNlvnoeSj2DB8wQpOO+/uPEi6iFny9n7kXLw4GJODYAn3YaPu",
	"zuxHTtweg/+hKT6vVq0xPl+W2IPn3Z2/ng+UuLYS2+HKZuFGdJ8zFn6TKSU5t7nWqzEgtHG2yPrDuGGW",
	"SE54JVdEga/LyqnZNj/EIS7aLebaVBHSa5ktsqLh/SWMpPPcNNS7Uto9CHD8esHesrB1ss8HVxC1rYz5",
	"dsDqnaPFRcG+GU7MgMIaxBKRCM71w8YeTkYnx6msaKmZzxdlSJKqNOd2kt9Wja5eI0KNS8ZzekO2h0op",
	"XS3BUsdLONkE3zXPuyJxVL+dlehLK8rNeOB1I3ZV858l1DcrRKRTDBEaJ3KsBXq977+P379D5qV1LNE5",
	"gpsYfAkBijHHEUjg4j5QsgIVziTdRK6gMNv/1aSaTpCQPPFlwuGewbii3cldvbbwoHyAi5vi4pQ8rbju",
	"XAG5YA5AoPOY7ctc0b46Pvc63un7sf7nQv3/6Pjt8fmx+vXwfPja63ivjw+PvI73/vR89P7duCxqzfd1",
	"pKyAf42EM5ZImx2v099ZurJfNCfdojjEPixYGBiWKmjSLzqFgC8/+SyA2/4Xn8jlrVdNe+89c+P2tanV",
	"tYRqncwuGZILIvK0avTE5lODjqXjIBCqUT0x++lds60rTJLtm15YF0fYjur+zRvwE0X7kNGAuCXI8U3M",
	"QeiMaYVjOAv1dQQ//QKHKOsmMz/NeMVN4iYS3Et9ZR9xIhfqmPtK416i//obkjyB7RwYjvFwTN7AMnez",
	"uhmRW+sCB+lkTgsLpAjqVCMtfEokx3xZEHC5LW+87E9mHKCr0AH6DMv+FQ4TyKXLU8+xQxunrTumrDDF",
	"qtz1bVPYmzmqECvaQi2hJrWUz+/PIhWWtTsug021it2cmmPg8HRU5ZTVt2ncfKQ5IVdE7TmqrJvUm6k6",
	"YHoRchbDvg+xUlbTpZE7Zjo9dK5+IVJAOENEIFzWdczXLrPePfJcIYj0Vdiv481Cdi1WsOGaLL80v2x1",
	"QK2oB+41XHonJ3TmpKhNK+Gh64ZZzR+CnkR4iQj1wySw+jXmMCM3KCSfAfVxTPpXu+VkoIWUsTjoq3c9",
	"m7er7WbTtmQSctIC2IbOzavGwGpTnBEIHWDlJ/UYyQWWNpBVCG2VpqHMzF7uUGmfEldBzSbK5kyHs77M",
	"2t09nRPnY0qZRGpDzNNWsQwNu2csdRxgk+tlRJv3z/H7XR36PrVODXRuXVgVNHU8PtftlGqKMMVzJVPq",
	"MfM0n7Le7yss4RovexM6ocqWs7+joQUBwK1MEg3d/u/hyVsFhLQ8MgxjbvQtKY6Ij8NwOaHpZyA0GRoE",
	"cvTkmF6xpXEHPUVXBKObozGKOZPMZ2EPjZM4ZlwKNEvCEA3PLo5QSGbgL/0QJlRN2UGS3gIOONSWuk1W",
	"FAbHpSPr2T579gaW6CfASluLg2fPJrSLxsk0IrLFVFXjs2yUQtBVzd1wEgdFPaFz1fZfwFk3YNdUt3fl",
	"YQvV7FRJQyGBKj5jHM/BTGj8j7dEgmrxjwT4clV6lElEM3aM59hOcxMu0wqekefmJiTV92m8H3uD3o8W",
	"aeoj2k8TtebgcPqfgeQErgDhPBy2OoXLTCoFib0JPQOZcCrQFAviFxNUbW4JYH+h+3miTkgnVVmdNMzQ",
	"saPp6JRa4qc9vQ4ZbB8FFuofno6UUOZWkehZ7Q4GmQPPKBFtAxjXZP/fwmhPkWl9dxJbK3VSvCziykGq",
	"aTFnissdFc5tTZAU7pdW021uO97+huuzagHKuRgOUkZUwQocau0G3BwmPQthMo9SctOb1bX0IInnQmkk",
	"9fJECUXQ8cRLrf6FdKU06VOPEYXrepep7KifJQXLKod5QolIxQEEHRTbAx2Ye86SYypCnT4tGTLyTwm9",
	"LBJkujRiakKnMCdU6LvjGixyPJsRPzNEFKnqJBGK9pEAZawJK9tyrYvOkjCTb9kN7h8y1OezaEqoaRqV",
	"8k7VB02q75f+L3pCJc33S/8XPYhEIWDFUFQJYANtdGv1ILekU/SgvvmJcSQUYSmF2dHOiPIZTWWjTYi1",
	"UxCOo24udxpZZ43SlyxYtmDj7ESlYZXSHdo0JJI5+71+DFLJ6iwZ9sA7BTlWT6ysLV4x/5h7Z6zjxPhJ",
	"dDf9LzHIUaCdGhlO/eg24DcwtS1VDls5N40XgAPg3oH3c/fwdNR9A0ttINEAS6aOnOqqaEykdsDt5W2n",
	"MCXrRSrMySu/v1j5OvM7uRal1LK8dnr9+4ReAdXkrqLJtGVcTff28hta6U4GDwXI17oXUerZ0pm+UvP5",
	"uWtz87tjG1vIsaURjWYRUnVY/dY8XfmxmytKcd2P1o7RJ+mgn52YnrjG8znwHmHK4FBflbsq2a/N18KV",
	"bmilfOo537edkhBY4ij8LgS+C4HvQuA/SgiUXBl27SsWws69IeB66QkHCm5ZduG24+19XXCusW2FtCe1",
	"pOOnhrIXX48ytaUh8SXqZrDYAEoNdxX4TAEvDjngYInghgj5OO0bwx9NBskqE+e2Y4z1/hc179v+Fzvr",
	"W2P1hOC6iXcGEVPmO3UYPzPOopXmj3XmCMliMaHGWVQ3VohwWytoRLuzkMwXElnJJZRFEitCJ7TI6/+j",
	"FyNrxMEHcgVob7CH3jGJfmIJDVxG/5GetFHChWi1kkfNoSZdYIchu2DN9aiI+tCmOFq5bP3aZXlSlE01",
	"87xKyIda6aIGWmx6iYOI3Kveno7Le/WKbJmFtG0tA7M6D16Upo2gdpKixeHe15MydbKUpT5Th+RRSjxz",
	"Sp0iaLVHZ7VH0lw5MuKkKtgYRzjLQtTDTpeISFHTGDWR8grk4eno5VJJjA9Zm02Ey+8vUh6xIFkDnipX",
	"i5pMuO37a3XG1Tfi+7Fec6xfgSOYos6Z44ytctsmjkNuqusokaGRnDPyZSCKCbCgomdWj51m+mDJbKiq",
	"Z6JgFtNYjGGCVmnZi/JU2gCaCc1EkIalqjcWVnqqwJtEQPOo1sc7imLGJaby4NkzNJpVr/6Jju4hW5wy",
	"4RwiTKhA2JfkClzAyazvdsDJkP04gJODlgeQd5u4mO/ZWfWQZu+9Su5KPaxW8s1ZbeaRm73fFUKjQmgj",
	"tNfZt9VCDWuC0mFo72Oi87fjcpkpW64gXKZlFWyeRLEqlnFSab0gytVnEOagBHWgseQVcDJbqgm9Pj8/",
	"HeeBL59RCjoBWzQFpYflmgAPdgabaqatiAiXFvtRx4LtJlfqK6ScVKyb1CoobEobWR+Mm4HSyHCdXUxg",
	"OH88oWkUk1B0enxiM2V6SNexsjW2Ou7OdL5fIlmEZZpPw6FSk+vJGHwOEh0R4bMr4Es0NrlhT9XXqQyV",
	"DMWJMACEwvWEVuZi4tExZzcE0kDykcnjQebgKqQxXGA6V6AIfwYEsxn4EpEogoBgCeFSYxyWKPij48Vp",
	"luM8yzRyIA01nWGprtDWQdtSzalHUBPKAotSeabWvurGUltf2WftLF3jcMK66sY9Ds1drHNo0hofp3os",
	"Cp3SgVgryKqqsW+khHbNOSXcCaaJkidIcjKfA0cYmU9c9XByR7AuE7kUEkxOhxEuEzo+Gqdpytp8mSUh",
	"IjO0ZMmfrwBF6Vg4CCCol520orQkkgQKCAdfMr60wugdMyJIDwM0iBkx1QjkMjayUcMfCqCFo7BMKExG",
	"IoRgM+RK4jSbvpm8U0mfQUVC3XMOmdPLWRwO1UT+A1Vv1RWHPk1b10yyVG1aOqmNa9U9/6o4eXRnODtW",
	"9jBtCkhq5/gLCVaGb1LfqQMBoekSjY5SmJGegAagoXPXykejxnVlNMFN4KjamxIVE/p7oQmzHGU0sdJ/",
	"MTpyFCRtCLm0DGM4PAv6UvUfMhpT5OQ0+PGgUmpD4fE4IjJFgr6NWMxWAEQb8p+CxNSD2yQ6Y0sHKk7I",
	"3ImO/HVzx4XQ+YHONV2daJ42aayamDZoKO2o7wQYrGM4VDN2mgNkLk1UoIiFPvomMEyT+ZzQeQdFjBLJ",
	"uP5ZdTHF/uckzu8IT5xRpryG6oN6BeqVWp0JFs4wmt7pR8nFSRS761EaFitwtNlhy8ELwKG5udzEvPqm",
	"guJO0zTljEaWre3sa/3dcAH+5/uFkS4paohcri3duGVNttreuI6sQCkV5T0yC4F8tRLZIWramLTaCIHt",
	"r6KU6lPd+UJK3tudr6XY8jLkvg2LlhdKIj/+VFjbDUpbFSri3P/NyGa3ZNNGPm4XZSPVOcvnTTa/utLQ",
	"/eO9wJIT7LjG0nCnI2U772Gibg1lRe8Uemvq8/GlnTZx0Pfk07bJp2WW/oOkoDawxXqxVdHbW2alNnHl",
	"/eWmrhBEXytDtSDXWmdbFCr8Ob0V5QJtXyPnYh1F/7Epq008/Lslrm5E0Nd2ljQR960ksW4tMO8voTUf",
	"YIO01lQIbZ3bmo36WOTQN5rnWi+hf2cIuj7PtVkk/D7Zrt+mFHgFshGxrM58bbb9Wua/Ngz7PQv2rlmw",
	"dwZnjiTU3xmcfatpsY/MQP/KCbJNguV7muwfUJO0l/DtLPFi8bs2SbOV5Nh69Cy3wP3c8p7Q03pDzCHt",
	"Rn9jkn5sum1WejXL90FY6qphaQRBx/6TWOsrnaugU3UjiExukNOlnv3ZrAc8s47KhCuc1o4/z/Wo3dWF",
	"oKjzL4ulLGf3u8xvqks9hktPvmW+rlh+BSGL7V97KVUHCFWDBRPy4MXghal7UEl6Yf5n4P03yRQ4BZ0s",
	"loVaqp3ZZJFuzlC218tsDjW/ugn62gifYTsd5UujVCJXjjZKVadRl6zLC38gd8m6vKNKtnu7DlfEFGy3",
	"TolQ7/xM77YVjGyGOCRCF0Z07n1a5aS29fWOzcvGJHw1iUrKvM6ltycgH6sh8eD28vb/AwAA//8ib9fH",
	"xokAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
