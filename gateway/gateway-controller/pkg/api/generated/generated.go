// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for APIConfigurationKind.
const (
	Httprest APIConfigurationKind = "http/rest"
)

// Defines values for APIConfigurationVersion.
const (
	ApiPlatformWso2Comv1 APIConfigurationVersion = "api-platform.wso2.com/v1"
)

// Defines values for APIDetailResponseApiMetadataStatus.
const (
	APIDetailResponseApiMetadataStatusDeployed APIDetailResponseApiMetadataStatus = "deployed"
	APIDetailResponseApiMetadataStatusFailed   APIDetailResponseApiMetadataStatus = "failed"
	APIDetailResponseApiMetadataStatusPending  APIDetailResponseApiMetadataStatus = "pending"
)

// Defines values for APIListItemStatus.
const (
	APIListItemStatusDeployed APIListItemStatus = "deployed"
	APIListItemStatusFailed   APIListItemStatus = "failed"
	APIListItemStatusPending  APIListItemStatus = "pending"
)

// Defines values for OperationMethod.
const (
	DELETE  OperationMethod = "DELETE"
	GET     OperationMethod = "GET"
	HEAD    OperationMethod = "HEAD"
	OPTIONS OperationMethod = "OPTIONS"
	PATCH   OperationMethod = "PATCH"
	POST    OperationMethod = "POST"
	PUT     OperationMethod = "PUT"
)

// APIConfigData defines model for APIConfigData.
type APIConfigData struct {
	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context"`

	// Name Human-readable API name (must be URL-friendly - only letters, numbers, spaces, hyphens, underscores, and dots allowed)
	Name string `json:"name"`

	// Operations List of HTTP operations/routes
	Operations []Operation `json:"operations"`

	// Policies List of API-level policies applied to all operations unless overridden
	Policies *[]Policy `json:"policies,omitempty"`

	// Upstream List of backend service URLs
	Upstream []Upstream `json:"upstream"`

	// Version Semantic version of the API
	Version string `json:"version"`
}

// APIConfiguration defines model for APIConfiguration.
type APIConfiguration struct {
	Data APIConfigData `json:"data"`

	// Kind API type
	Kind APIConfigurationKind `json:"kind"`

	// Version API specification version
	Version APIConfigurationVersion `json:"version"`
}

// APIConfigurationKind API type
type APIConfigurationKind string

// APIConfigurationVersion API specification version
type APIConfigurationVersion string

// APICreateResponse defines model for APICreateResponse.
type APICreateResponse struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id Unique identifier for the created API configuration
	Id      *openapi_types.UUID `json:"id,omitempty"`
	Message *string             `json:"message,omitempty"`
	Status  *string             `json:"status,omitempty"`
}

// APIDetailResponse defines model for APIDetailResponse.
type APIDetailResponse struct {
	Api *struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty"`
			Status     *APIDetailResponseApiMetadataStatus `json:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty"`
		} `json:"metadata,omitempty"`
	} `json:"api,omitempty"`
	Status *string `json:"status,omitempty"`
}

// APIDetailResponseApiMetadataStatus defines model for APIDetailResponse.Api.Metadata.Status.
type APIDetailResponseApiMetadataStatus string

// APIListItem defines model for APIListItem.
type APIListItem struct {
	Context   *string             `json:"context,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Status    *APIListItemStatus  `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	Version   *string             `json:"version,omitempty"`
}

// APIListItemStatus defines model for APIListItem.Status.
type APIListItemStatus string

// APIUpdateResponse defines model for APIUpdateResponse.
type APIUpdateResponse struct {
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Message   *string             `json:"message,omitempty"`
	Status    *string             `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors Detailed validation errors
	Errors *[]ValidationError `json:"errors,omitempty"`

	// Message High-level error description
	Message string `json:"message"`
	Status  string `json:"status"`
}

// Operation defines model for Operation.
type Operation struct {
	// Method HTTP method
	Method OperationMethod `json:"method"`

	// Path Route path with optional {param} placeholders
	Path string `json:"path"`

	// Policies List of policies applied only to this operation (overrides or adds to API-level policies)
	Policies *[]Policy `json:"policies,omitempty"`
}

// OperationMethod HTTP method
type OperationMethod string

// Policy defines model for Policy.
type Policy struct {
	// ExecutionCondition Expression controlling conditional execution of the policy
	ExecutionCondition *string `json:"executionCondition,omitempty"`

	// Name Name of the policy
	Name string `json:"name"`

	// Params Arbitrary parameters for the policy (free-form key/value structure)
	Params *map[string]interface{} `json:"params,omitempty"`

	// Version Semantic version of the policy
	Version string `json:"version"`
}

// PolicyDefinition defines model for PolicyDefinition.
type PolicyDefinition struct {
	// Description Human readable description of the policy's purpose
	Description *string `json:"description,omitempty"`

	// Flows Flow configuration indicating what the policy needs from the engine
	Flows PolicyDefinition_Flows `json:"flows"`

	// Name Unique policy name
	Name string `json:"name"`

	// ParametersSchema JSON Schema describing the parameters accepted by this policy. This itself is a JSON Schema document.
	ParametersSchema *map[string]interface{} `json:"parametersSchema,omitempty"`

	// Version Semantic version of the policy definition
	Version string `json:"version"`
}

// PolicyDefinition_Flows Flow configuration indicating what the policy needs from the engine
type PolicyDefinition_Flows struct {
	Request              *PolicyFlowRequirements           `json:"request,omitempty"`
	Response             *PolicyFlowRequirements           `json:"response,omitempty"`
	AdditionalProperties map[string]PolicyFlowRequirements `json:"-"`
}

// PolicyFlowRequirements defines model for PolicyFlowRequirements.
type PolicyFlowRequirements struct {
	// RequireBody Whether request/response body content is required for execution
	RequireBody *bool `json:"requireBody,omitempty"`

	// RequireHeader Whether request/response headers are required for execution
	RequireHeader *bool `json:"requireHeader,omitempty"`
}

// PolicyListResponse defines model for PolicyListResponse.
type PolicyListResponse struct {
	Count    *int                `json:"count,omitempty"`
	Policies *[]PolicyDefinition `json:"policies,omitempty"`
	Status   *string             `json:"status,omitempty"`
}

// Upstream defines model for Upstream.
type Upstream struct {
	// Url Backend service URL (may include path prefix like /api/v2)
	Url string `json:"url"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field that failed validation
	Field *string `json:"field,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`
}

// CreateAPIJSONRequestBody defines body for CreateAPI for application/json ContentType.
type CreateAPIJSONRequestBody = APIConfiguration

// UpdateAPIJSONRequestBody defines body for UpdateAPI for application/json ContentType.
type UpdateAPIJSONRequestBody = APIConfiguration

// Getter for additional properties for PolicyDefinition_Flows. Returns the specified
// element and whether it was found
func (a PolicyDefinition_Flows) Get(fieldName string) (value PolicyFlowRequirements, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PolicyDefinition_Flows
func (a *PolicyDefinition_Flows) Set(fieldName string, value PolicyFlowRequirements) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]PolicyFlowRequirements)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PolicyDefinition_Flows to handle AdditionalProperties
func (a *PolicyDefinition_Flows) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["request"]; found {
		err = json.Unmarshal(raw, &a.Request)
		if err != nil {
			return fmt.Errorf("error reading 'request': %w", err)
		}
		delete(object, "request")
	}

	if raw, found := object["response"]; found {
		err = json.Unmarshal(raw, &a.Response)
		if err != nil {
			return fmt.Errorf("error reading 'response': %w", err)
		}
		delete(object, "response")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]PolicyFlowRequirements)
		for fieldName, fieldBuf := range object {
			var fieldVal PolicyFlowRequirements
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PolicyDefinition_Flows to handle AdditionalProperties
func (a PolicyDefinition_Flows) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Request != nil {
		object["request"], err = json.Marshal(a.Request)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'request': %w", err)
		}
	}

	if a.Response != nil {
		object["response"], err = json.Marshal(a.Response)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'response': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all API configurations
	// (GET /apis)
	ListAPIs(c *gin.Context)
	// Create a new API configuration
	// (POST /apis)
	CreateAPI(c *gin.Context)
	// Delete an API configuration
	// (DELETE /apis/{name}/{version})
	DeleteAPI(c *gin.Context, name string, version string)
	// Get API configuration by name and version
	// (GET /apis/{name}/{version})
	GetAPIByNameVersion(c *gin.Context, name string, version string)
	// Update an existing API configuration
	// (PUT /apis/{name}/{version})
	UpdateAPI(c *gin.Context, name string, version string)
	// Health check endpoint
	// (GET /health)
	HealthCheck(c *gin.Context)
	// List all registered policy definitions
	// (GET /policies)
	ListPolicies(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListAPIs operation middleware
func (siw *ServerInterfaceWrapper) ListAPIs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAPIs(c)
}

// CreateAPI operation middleware
func (siw *ServerInterfaceWrapper) CreateAPI(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateAPI(c)
}

// DeleteAPI operation middleware
func (siw *ServerInterfaceWrapper) DeleteAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAPI(c, name, version)
}

// GetAPIByNameVersion operation middleware
func (siw *ServerInterfaceWrapper) GetAPIByNameVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAPIByNameVersion(c, name, version)
}

// UpdateAPI operation middleware
func (siw *ServerInterfaceWrapper) UpdateAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateAPI(c, name, version)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HealthCheck(c)
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPolicies(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/apis", wrapper.ListAPIs)
	router.POST(options.BaseURL+"/apis", wrapper.CreateAPI)
	router.DELETE(options.BaseURL+"/apis/:name/:version", wrapper.DeleteAPI)
	router.GET(options.BaseURL+"/apis/:name/:version", wrapper.GetAPIByNameVersion)
	router.PUT(options.BaseURL+"/apis/:name/:version", wrapper.UpdateAPI)
	router.GET(options.BaseURL+"/health", wrapper.HealthCheck)
	router.GET(options.BaseURL+"/policies", wrapper.ListPolicies)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xbe3McN3L/KsjkqiLJsw/SpBMxlT9okbIY66w9PnwXaxkbO9O7ixMGmAMwS05Y+91T",
	"Dcx7sMslTSpyRf9I5ODV3ejXr9G8CyKZpFKAMDo4ugt0tISE2h+PJ2dvpJizxQk1FD+kSqagDAM7HElh",
	"4NbgjzHoSLHUMCmCo+B7qoGk1CzJXCpCOSfHkzOiZGZAkxdJpg3RhipDbphZklFIhCRGUcaZWBDNqV6+",
	"DMIAbmmScgiOgtENULMEFYRBQm/fg1iYZXC0Px6HQcJE+fteGKTUGFBIwn9Pp6OPdPA/x4NfxoPXv06n",
	"g+l0dP3qI36//lMQBiZPcWttFBOLYB0GgibQZ+VdllAxUEBjOuNg+cCJBRczIFfn7wdzxUDEPCcDIgXP",
	"CQckQ4dEZMnM/qBTGoEOyTJPlyB0SDIRg9KRVPiVipjE0mgUlbyBuM19wfyApqwtgL2tAqi5n04Hv06n",
	"Q3L9jZdxvFKK7Oo++++ZNkTOybvLywmpJ47cXQZhwAwkdt2fFMyDo+CfR7U2jQpVGn0oF+JxCRNnbtFe",
	"RQxViuY4mErOokK9/JQcT84GHFbASTmX0DTlDGJipNW1mkySCQ5aE7kCpVgcg9iV4gnubSnqUpil2iig",
	"yWYKZzT6BCImGtSKRVZDdpbUVbn7fYJagdL22C4VF5BQYVhEihlIkVlazW1p1WpvOA5aCrOaTuNvptMh",
	"/udRlHUYKPhHxhTEwdFHZy41HWHlDRoiaunWdbWjnP0dIoNcVA4mK/Sj52PiwvNsE1rbTa3D4BMTcV8y",
	"aLuWgjAAkSXIxNKYdKRAG6Sulk392WMuGyWP++sUIjZnkeWG1MIpD6QpG6ScmrlUyfBGy/1hJJPRaq99",
	"/sZZ911KfaAVQejEt0nyCqiBc9CpFBo87t2Ox79S6+Fr6vbH+4eDvfFgb+9yb3z07fhoPP4lCAMkFqfi",
	"mTAwzKpHT3rMczFXgv0jA8JiEIbNGSgbNlBpCxKs241aitIU1+HhGP7tYDwewP7r2eBgLz4Y0H/d+25w",
	"cPDdd4eHBwfj8XjcJDDLWOyjLQGt6QLa3PaOrojSWRSB1vOM89y3nTbUZLq9W7HGe5G+OzoBQxnffEcY",
	"E3xxuW1SOxlPVrtod0nPIWBDY38q8Ry6FkPKZb7Troe779q41sKoUxAxDtYn4maUcYjbdt0Y7m2bpfFT",
	"S6CvUz4tewo1xdCHsWprjujN53pyeEav8/QKXeaMm5K1P7DytAJdL23YTS2uLFmbvdfz+ZmdHHkhtad1",
	"5Ltdxt7RweHvsuQwOFVKqs2yBRz25NEuokBMVpSz2AmimLtjjvpztdCS4EuSGxfQgVNssSzSd3soaQ43",
	"tb0Vk5q0Fqax4zXZQ+5Nm4qVNd2+jKkGMT1ZJ2CW0pPYWNRUDNY54A+nl0EYTD5c2P+u8N+T0/enl6f4",
	"6/Hlm3dBGLw7PT4JwuDD5PLsw08XbUfg1vfYR7zdJ+EcgZrD4hZsSztAOblLqaLJmqScRrCUHOFoG3Tf",
	"RTITRuW/RjKG9eguYiZfB12QPXzlBZX3A7kefLPQ2UhilkzXII68KNAbaCIVoXGscVIfBr78vdiuoxTV",
	"vVnB+jSi2KhvercQZUj7GyliZrxg4fQ2VaAtQMMQqSS3xY+oXEE5qbYpIVzqzmteEhIM2gzLzOojzcwS",
	"0+gIXdA1+af/IEZlsHu94yeawJbzaMp+hLz2AH5FVNTdAo1LZiYNASFBYRc7qRkziqqc2NVgQOkKBTg6",
	"yIu5AhiguySfIB+tKM+AaKOyyGQKXgaeG3owSvawjBFvG1R+LGLerFEnMGeCbcDDTTa8xSpSFasag23+",
	"/kWTNFOp1NCrqI09Fzrn8mbLfe5ibW+5vDl3skhsoXHd1QCc0YnPTMQWSYsFuVlS09QFARBrMlcysV9B",
	"LJiwzDDRJG0v7IivsJfHE60aAfcxO/giud8SC1RcMuyUp5XOdC1xe23Ub6fW0i4s0Q+z2P+8+PATcQsL",
	"RZvhRdk7qk2YRhGkmGPNcufXHTtDcom/MKOBzwnThJLWfjLKUF7DJ7RpEtdW9TnMuzSbzWbeU46esRfb",
	"fy/jvM/uX5eASIMUKj0qNZPMZJzboALCoGxLIq0/rYJKUwhzyjVUdM6k5EBFUPP3DmgM6gEkLO0CTaiC",
	"HY536tU9fb1RcJhBbClbYdbSygL3q52YMLAA1U1QHpA2NHyzJ+/93Vj6qlFdbrOVKe57aOmVmsmLhOaE",
	"iYhncZH4pQrm7JZw9gnIiKZstNpvvzAsjUn10QjHhgWAtRVHN7eFuBS71xCQUp/Wd3FDj8U5A+7Jot/i",
	"Z2IwAsy70KXFBiZAw7oMvQ0Wbn3kcciknN1BJbg56T1h2SeciAohDcELcV93Ksmsw4CJuSyLJTSyyuti",
	"QvDXiw/7tvo5KcrB5LJ4Heik+acXl3YeGllCBV2gM+5BXk2YsD6xv+8P1MANzYdTMRWXSyh/J2+K7BRU",
	"4cz1hm3/6/jP7zFDt47cKYx72MoFTVhEOc+nolwG2pJh0YkiL07FSuZkouRt/pKsGCW3JxckVdLISPIh",
	"ucjSVCqjCUJ08ub86oRwNocojzhMBbLsIclegQLKLaYuwL52AKM82XL76tWPkJO3QDGN1EevXk3FgFxk",
	"s4SZHVjFyefVKQ2girw7TVKA1DOxwLm/gJKDWN4IO99XkNA4bYJhRFsXro1UdAGOoYu/vGcGcMZfMlAY",
	"1VxVyEPp1GbnzDjQ2L9O9yJUhdPABUL3IChsYTn4djgefltAIGui6BLsDwvwvPueg1EMVkAo4QXKo5xv",
	"o9ExVaKX4VScg8mU0GRGNYsIGgYqkpXnTGaGAI2Wdp8XaCFhGetDUth9WJyGEZWgiF8OrRwqPHkWFxj0",
	"eHKGTrmMWZar/fG4Klq6IGLBqXvOGf1du7RDV+lSrxi/ezhpVk09kaQfxQ59Uex3Bpx1z5E0nlk7V4XH",
	"HT5QPtsE0K5feUg5E5iPUW6jGyhnTJYLnSUJVXlJbtlg0KE3DAxdaIxIOPhndIo20QqubfjXHgUurJ4S",
	"ATf9LUvf0bclzGc7xjwVTJfuAOKQpIVBx+653ygqNLflRyOJ83/o9BRomakItNvSuampmMGCCW1bKGyW",
	"reh8zqIKISOpaElMkEOiIZIi1oVvq6MuOc945d+qRoZvqnQ5ksmMCTe17G7ILAjBBZtC32+j3yxDrcj3",
	"2+g3e4ghHCgqlEAH7FIbOxs/1CWeMnvANW+lIhoJKymsTLsiKpKi9I00UlLrkgXtMXX3yul8XZGnlvn0",
	"PWpcWVT9Cl29ZgSjFAw6ZswPilg9AXOBXwrH2myr+FjXCIvynavW2W1GdymYs9iW1qqk9KO/jPSAgk9B",
	"ladiUxdolkViH/xtcDw5G/wIuYWRIqZGon3hVk3IVaKl9fU6bLBU1DIbPAXt8autw1X10yeU1sy27Kz8",
	"R0ysQFhyt9Hk5kqF7K6v/0CSDqtcUINxQEy3di7oLIeQn78Nzt3HwYV1Js1E0vlBJ4Qy9nXXuq9bF/u1",
	"otke87HALBZdHI0qgxnqG7pYgBoyieACF7V3qjs4Wo0Y9aSN7REYGnaKPf1H73XY8gE5TfhXH/DVB3z1",
	"Af+ffECrkFHcRgcf7D1Z/tvvwPLkwDt2H63D4ODzpuY2s+2Q9qL3TPvSUfb681GGV8pZZMigSopdOmmT",
	"XUw9y3SXcgU0zgncMm2+THTj9GMTHNkGcNahg+qjO+R7PboruF47zMPBgA++JxLBu/BAn+qpZRP4KUo5",
	"2shUT4UrFfWhCtN+rELOxGDO2WJpymKyRjySIqFT0dT1f7fCqCYpiICtgByMD8hP0pC3MhOxD/KfWKZd",
	"WK4fKKyL2vwCaltGJSkEtrkpm+FCG2aqSFA8B7T9SdM39cB5l5Cfew28G2gpenI8RNSPEbvTcf2kNZFH",
	"tvg8tqXHSefZezN3cdReUqw7PPh8XqZPFuL0ORrJF+nxnJV6XdD2es72eqTtJS7cSdexSUVo1bdtj53l",
	"hBndixg9l/IDmOPJ2fc5eoyfqzkPcS7/9y7lC3Yk9yRPndboTQju8fvtZOO4Rn8163vM+gfwPKWgnXls",
	"bFvRNvMYuWsyRZdhMznvu5dLUdzzCmnWZe3ZZQMaNbJ4qBq6N7AipylyDPdkVTaNtlnZJaGZisoF2bQU",
	"d5O8s1Mnvck0bD61qPCeJalUhgpz9OoVOZt3myV16FpkSuG0CVeQUCY0oZFhK/AlTk6+j0ucHNlfRuLk",
	"oeUZ/N1DCsxPXKt6Ttj7pJ670xa+k3/z9mp/4bD3a0DYGBB2cdr34dslUO5anjclf/YlGV2Am0pc1l/6",
	"hT6S7fm+d3bdmyVEn572qdiHPxyRXrhiWALa0CS1bTKP+9Of3j15WgKYJiUV7ftygiARSoKAiFPJhGlc",
	"0EWuDSTFxTRbq+7pE+CcRJlSIAzPCZc0hrjfr9do9IzqqsNUTPoTqYJyG7tmzjhUTS9Vx3nMFERGqpxQ",
	"Y3tSSv7tu2aW2qzAFipjXJtAIlW+qY9gUnL7jE7T0/e25e2+L8Av++1ewYJpA8p79w0lK+677QhwS3uG",
	"LyV5LyPKSQwr4DK1K8J2QZrjhKXU5uj1+LWrtHf+XEZGn0CNfsxmoAQYVJ6qv6S72cIZ1KBWqGLX64qH",
	"XsOBtZvSPzm1sz6qtDFd5ySFjfVptA1Rjb969zdE1Rt1vGl/w3N7IUUgkXOiINO2M857PeXTV+921tfr",
	"/w0AAP//CAgPJ11CAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
