// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for APIConfigurationKind.
const (
	Httprest APIConfigurationKind = "http/rest"
)

// Defines values for APIConfigurationVersion.
const (
	ApiPlatformWso2Comv1 APIConfigurationVersion = "api-platform.wso2.com/v1"
)

// Defines values for APIDetailResponseApiMetadataStatus.
const (
	APIDetailResponseApiMetadataStatusDeployed APIDetailResponseApiMetadataStatus = "deployed"
	APIDetailResponseApiMetadataStatusFailed   APIDetailResponseApiMetadataStatus = "failed"
	APIDetailResponseApiMetadataStatusPending  APIDetailResponseApiMetadataStatus = "pending"
)

// Defines values for APIListItemStatus.
const (
	APIListItemStatusDeployed APIListItemStatus = "deployed"
	APIListItemStatusFailed   APIListItemStatus = "failed"
	APIListItemStatusPending  APIListItemStatus = "pending"
)

// Defines values for OperationMethod.
const (
	DELETE  OperationMethod = "DELETE"
	GET     OperationMethod = "GET"
	HEAD    OperationMethod = "HEAD"
	OPTIONS OperationMethod = "OPTIONS"
	PATCH   OperationMethod = "PATCH"
	POST    OperationMethod = "POST"
	PUT     OperationMethod = "PUT"
)

// APIConfigData defines model for APIConfigData.
type APIConfigData struct {
	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context"`

	// Name Human-readable API name (must be URL-friendly - only letters, numbers, spaces, hyphens, underscores, and dots allowed)
	Name string `json:"name"`

	// Operations List of HTTP operations/routes
	Operations []Operation `json:"operations"`

	// Policies List of API-level policies applied to all operations unless overridden
	Policies *[]Policy `json:"policies,omitempty"`

	// Upstreams List of backend service URLs
	Upstreams []Upstream `json:"upstreams"`

	// Version Semantic version of the API
	Version string `json:"version"`
}

// APIConfiguration defines model for APIConfiguration.
type APIConfiguration struct {
	// Kind API type
	Kind APIConfigurationKind `json:"kind"`
	Spec APIConfigData        `json:"spec"`

	// Version API specification version
	Version APIConfigurationVersion `json:"version"`
}

// APIConfigurationKind API type
type APIConfigurationKind string

// APIConfigurationVersion API specification version
type APIConfigurationVersion string

// APICreateResponse defines model for APICreateResponse.
type APICreateResponse struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id Unique identifier for the created API configuration
	Id      *openapi_types.UUID `json:"id,omitempty"`
	Message *string             `json:"message,omitempty"`
	Status  *string             `json:"status,omitempty"`
}

// APIDetailResponse defines model for APIDetailResponse.
type APIDetailResponse struct {
	Api *struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty"`
			Status     *APIDetailResponseApiMetadataStatus `json:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty"`
		} `json:"metadata,omitempty"`
	} `json:"api,omitempty"`
	Status *string `json:"status,omitempty"`
}

// APIDetailResponseApiMetadataStatus defines model for APIDetailResponse.Api.Metadata.Status.
type APIDetailResponseApiMetadataStatus string

// APIListItem defines model for APIListItem.
type APIListItem struct {
	Context   *string             `json:"context,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Status    *APIListItemStatus  `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	Version   *string             `json:"version,omitempty"`
}

// APIListItemStatus defines model for APIListItem.Status.
type APIListItemStatus string

// APIUpdateResponse defines model for APIUpdateResponse.
type APIUpdateResponse struct {
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Message   *string             `json:"message,omitempty"`
	Status    *string             `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors Detailed validation errors
	Errors *[]ValidationError `json:"errors,omitempty"`

	// Message High-level error description
	Message string `json:"message"`
	Status  string `json:"status"`
}

// Operation defines model for Operation.
type Operation struct {
	// Method HTTP method
	Method OperationMethod `json:"method"`

	// Path Route path with optional {param} placeholders
	Path string `json:"path"`

	// Policies List of policies applied only to this operation (overrides or adds to API-level policies)
	Policies *[]Policy `json:"policies,omitempty"`
}

// OperationMethod HTTP method
type OperationMethod string

// Policy defines model for Policy.
type Policy struct {
	// ExecutionCondition Expression controlling conditional execution of the policy
	ExecutionCondition *string `json:"executionCondition,omitempty"`

	// Name Name of the policy
	Name string `json:"name"`

	// Params Arbitrary parameters for the policy (free-form key/value structure)
	Params *map[string]interface{} `json:"params,omitempty"`

	// Version Semantic version of the policy
	Version string `json:"version"`
}

// PolicyDefinition defines model for PolicyDefinition.
type PolicyDefinition struct {
	// Description Human readable description of the policy's purpose
	Description *string `json:"description,omitempty"`

	// Name Unique policy name
	Name string `json:"name"`

	// ParametersSchema JSON Schema describing the parameters accepted by this policy. This itself is a JSON Schema document.
	ParametersSchema *map[string]interface{} `json:"parametersSchema,omitempty"`

	// Version Semantic version of the policy definition
	Version string `json:"version"`
}

// PolicyListResponse defines model for PolicyListResponse.
type PolicyListResponse struct {
	Count    *int                `json:"count,omitempty"`
	Policies *[]PolicyDefinition `json:"policies,omitempty"`
	Status   *string             `json:"status,omitempty"`
}

// Upstream defines model for Upstream.
type Upstream struct {
	// Url Backend service URL (may include path prefix like /api/v2)
	Url string `json:"url"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field that failed validation
	Field *string `json:"field,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`
}

// CreateAPIJSONRequestBody defines body for CreateAPI for application/json ContentType.
type CreateAPIJSONRequestBody = APIConfiguration

// UpdateAPIJSONRequestBody defines body for UpdateAPI for application/json ContentType.
type UpdateAPIJSONRequestBody = APIConfiguration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all API configurations
	// (GET /apis)
	ListAPIs(c *gin.Context)
	// Create a new API configuration
	// (POST /apis)
	CreateAPI(c *gin.Context)
	// Delete an API configuration
	// (DELETE /apis/{name}/{version})
	DeleteAPI(c *gin.Context, name string, version string)
	// Get API configuration by name and version
	// (GET /apis/{name}/{version})
	GetAPIByNameVersion(c *gin.Context, name string, version string)
	// Update an existing API configuration
	// (PUT /apis/{name}/{version})
	UpdateAPI(c *gin.Context, name string, version string)
	// Health check endpoint
	// (GET /health)
	HealthCheck(c *gin.Context)
	// List all registered policy definitions
	// (GET /policies)
	ListPolicies(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListAPIs operation middleware
func (siw *ServerInterfaceWrapper) ListAPIs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAPIs(c)
}

// CreateAPI operation middleware
func (siw *ServerInterfaceWrapper) CreateAPI(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateAPI(c)
}

// DeleteAPI operation middleware
func (siw *ServerInterfaceWrapper) DeleteAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAPI(c, name, version)
}

// GetAPIByNameVersion operation middleware
func (siw *ServerInterfaceWrapper) GetAPIByNameVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAPIByNameVersion(c, name, version)
}

// UpdateAPI operation middleware
func (siw *ServerInterfaceWrapper) UpdateAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateAPI(c, name, version)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HealthCheck(c)
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPolicies(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/apis", wrapper.ListAPIs)
	router.POST(options.BaseURL+"/apis", wrapper.CreateAPI)
	router.DELETE(options.BaseURL+"/apis/:name/:version", wrapper.DeleteAPI)
	router.GET(options.BaseURL+"/apis/:name/:version", wrapper.GetAPIByNameVersion)
	router.PUT(options.BaseURL+"/apis/:name/:version", wrapper.UpdateAPI)
	router.GET(options.BaseURL+"/health", wrapper.HealthCheck)
	router.GET(options.BaseURL+"/policies", wrapper.ListPolicies)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//WJX8JGFCAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
