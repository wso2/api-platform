// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for APIConfigurationKind.
const (
	Httprest APIConfigurationKind = "http/rest"
)

// Defines values for APIConfigurationVersion.
const (
	ApiPlatformWso2Comv1 APIConfigurationVersion = "api-platform.wso2.com/v1"
)

// Defines values for APIDetailResponseApiMetadataStatus.
const (
	APIDetailResponseApiMetadataStatusDeployed APIDetailResponseApiMetadataStatus = "deployed"
	APIDetailResponseApiMetadataStatusFailed   APIDetailResponseApiMetadataStatus = "failed"
	APIDetailResponseApiMetadataStatusPending  APIDetailResponseApiMetadataStatus = "pending"
)

// Defines values for APIListItemStatus.
const (
	APIListItemStatusDeployed APIListItemStatus = "deployed"
	APIListItemStatusFailed   APIListItemStatus = "failed"
	APIListItemStatusPending  APIListItemStatus = "pending"
)

// Defines values for OperationMethod.
const (
	DELETE  OperationMethod = "DELETE"
	GET     OperationMethod = "GET"
	HEAD    OperationMethod = "HEAD"
	OPTIONS OperationMethod = "OPTIONS"
	PATCH   OperationMethod = "PATCH"
	POST    OperationMethod = "POST"
	PUT     OperationMethod = "PUT"
)

// APIConfigData defines model for APIConfigData.
type APIConfigData struct {
	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context"`

	// Name Human-readable API name (must be URL-friendly - only letters, numbers, spaces, hyphens, underscores, and dots allowed)
	Name string `json:"name"`

	// Operations List of HTTP operations/routes
	Operations []Operation `json:"operations"`

	// Policies List of API-level policies applied to all operations unless overridden
	Policies *[]Policy `json:"policies,omitempty"`

	// Upstream List of backend service URLs
	Upstream []Upstream `json:"upstream"`

	// Version Semantic version of the API
	Version string `json:"version"`
}

// APIConfiguration defines model for APIConfiguration.
type APIConfiguration struct {
	Data APIConfigData `json:"data"`

	// Kind API type
	Kind APIConfigurationKind `json:"kind"`

	// Version API specification version
	Version APIConfigurationVersion `json:"version"`
}

// APIConfigurationKind API type
type APIConfigurationKind string

// APIConfigurationVersion API specification version
type APIConfigurationVersion string

// APICreateResponse defines model for APICreateResponse.
type APICreateResponse struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id Unique identifier for the created API configuration
	Id      *openapi_types.UUID `json:"id,omitempty"`
	Message *string             `json:"message,omitempty"`
	Status  *string             `json:"status,omitempty"`
}

// APIDetailResponse defines model for APIDetailResponse.
type APIDetailResponse struct {
	Api *struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty"`
			Status     *APIDetailResponseApiMetadataStatus `json:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty"`
		} `json:"metadata,omitempty"`
	} `json:"api,omitempty"`
	Status *string `json:"status,omitempty"`
}

// APIDetailResponseApiMetadataStatus defines model for APIDetailResponse.Api.Metadata.Status.
type APIDetailResponseApiMetadataStatus string

// APIListItem defines model for APIListItem.
type APIListItem struct {
	Context   *string             `json:"context,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Status    *APIListItemStatus  `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	Version   *string             `json:"version,omitempty"`
}

// APIListItemStatus defines model for APIListItem.Status.
type APIListItemStatus string

// APIUpdateResponse defines model for APIUpdateResponse.
type APIUpdateResponse struct {
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Message   *string             `json:"message,omitempty"`
	Status    *string             `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors Detailed validation errors
	Errors *[]ValidationError `json:"errors,omitempty"`

	// Message High-level error description
	Message string `json:"message"`
	Status  string `json:"status"`
}

// Operation defines model for Operation.
type Operation struct {
	// Method HTTP method
	Method OperationMethod `json:"method"`

	// Path Route path with optional {param} placeholders
	Path string `json:"path"`

	// Policies List of policies applied only to this operation (overrides or adds to API-level policies)
	Policies *[]Policy `json:"policies,omitempty"`
}

// OperationMethod HTTP method
type OperationMethod string

// Policy defines model for Policy.
type Policy struct {
	// ExecutionCondition Expression controlling conditional execution of the policy
	ExecutionCondition *string `json:"executionCondition,omitempty"`

	// Name Name of the policy
	Name string `json:"name"`

	// Params Arbitrary parameters for the policy (free-form key/value structure)
	Params *map[string]interface{} `json:"params,omitempty"`

	// Version Semantic version of the policy
	Version string `json:"version"`
}

// PolicyCreateResponse defines model for PolicyCreateResponse.
type PolicyCreateResponse struct {
	Count   *int                `json:"count,omitempty"`
	Created *[]PolicyDefinition `json:"created,omitempty"`
	Message *string             `json:"message,omitempty"`
	Status  *string             `json:"status,omitempty"`
}

// PolicyDefinition defines model for PolicyDefinition.
type PolicyDefinition struct {
	// Description Human readable description of the policy's purpose
	Description *string `json:"description,omitempty"`

	// Flows Indicates required request/response components for policy execution
	Flows struct {
		Request  *PolicyFlowRequirements `json:"request,omitempty"`
		Response *PolicyFlowRequirements `json:"response,omitempty"`
	} `json:"flows"`

	// Name Unique policy name
	Name string `json:"name"`

	// ParametersSchema JSON schema (or arbitrary structure) describing parameters accepted when attaching this policy
	ParametersSchema *map[string]interface{} `json:"parametersSchema,omitempty"`

	// Provider Organization or entity providing the policy implementation
	Provider string `json:"provider"`

	// Version Semantic version of the policy definition
	Version string `json:"version"`
}

// PolicyFlowRequirements defines model for PolicyFlowRequirements.
type PolicyFlowRequirements struct {
	// RequireBody Whether request/response body content is required for execution
	RequireBody *bool `json:"requireBody,omitempty"`

	// RequireHeader Whether request/response headers are required for execution
	RequireHeader *bool `json:"requireHeader,omitempty"`
}

// PolicyListResponse defines model for PolicyListResponse.
type PolicyListResponse struct {
	Count    *int                `json:"count,omitempty"`
	Policies *[]PolicyDefinition `json:"policies,omitempty"`
	Status   *string             `json:"status,omitempty"`
}

// Upstream defines model for Upstream.
type Upstream struct {
	// Url Backend service URL (may include path prefix like /api/v2)
	Url string `json:"url"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field that failed validation
	Field *string `json:"field,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`
}

// CreatePoliciesJSONBody defines parameters for CreatePolicies.
type CreatePoliciesJSONBody = []PolicyDefinition

// CreateAPIJSONRequestBody defines body for CreateAPI for application/json ContentType.
type CreateAPIJSONRequestBody = APIConfiguration

// UpdateAPIJSONRequestBody defines body for UpdateAPI for application/json ContentType.
type UpdateAPIJSONRequestBody = APIConfiguration

// CreatePoliciesJSONRequestBody defines body for CreatePolicies for application/json ContentType.
type CreatePoliciesJSONRequestBody = CreatePoliciesJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all API configurations
	// (GET /apis)
	ListAPIs(c *gin.Context)
	// Create a new API configuration
	// (POST /apis)
	CreateAPI(c *gin.Context)
	// Delete an API configuration
	// (DELETE /apis/{name}/{version})
	DeleteAPI(c *gin.Context, name string, version string)
	// Get API configuration by name and version
	// (GET /apis/{name}/{version})
	GetAPIByNameVersion(c *gin.Context, name string, version string)
	// Update an existing API configuration
	// (PUT /apis/{name}/{version})
	UpdateAPI(c *gin.Context, name string, version string)
	// Health check endpoint
	// (GET /health)
	HealthCheck(c *gin.Context)
	// List registered policy definitions
	// (GET /policies)
	ListPolicies(c *gin.Context)
	// Create policy definitions
	// (POST /policies)
	CreatePolicies(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListAPIs operation middleware
func (siw *ServerInterfaceWrapper) ListAPIs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAPIs(c)
}

// CreateAPI operation middleware
func (siw *ServerInterfaceWrapper) CreateAPI(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateAPI(c)
}

// DeleteAPI operation middleware
func (siw *ServerInterfaceWrapper) DeleteAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAPI(c, name, version)
}

// GetAPIByNameVersion operation middleware
func (siw *ServerInterfaceWrapper) GetAPIByNameVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAPIByNameVersion(c, name, version)
}

// UpdateAPI operation middleware
func (siw *ServerInterfaceWrapper) UpdateAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateAPI(c, name, version)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HealthCheck(c)
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPolicies(c)
}

// CreatePolicies operation middleware
func (siw *ServerInterfaceWrapper) CreatePolicies(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreatePolicies(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/apis", wrapper.ListAPIs)
	router.POST(options.BaseURL+"/apis", wrapper.CreateAPI)
	router.DELETE(options.BaseURL+"/apis/:name/:version", wrapper.DeleteAPI)
	router.GET(options.BaseURL+"/apis/:name/:version", wrapper.GetAPIByNameVersion)
	router.PUT(options.BaseURL+"/apis/:name/:version", wrapper.UpdateAPI)
	router.GET(options.BaseURL+"/health", wrapper.HealthCheck)
	router.GET(options.BaseURL+"/policies", wrapper.ListPolicies)
	router.POST(options.BaseURL+"/policies", wrapper.CreatePolicies)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
