// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for APIConfigDataApiType.
const (
	APIConfigDataApiTypeHttprest APIConfigDataApiType = "http/rest"
)

// Defines values for APIConfigurationKind.
const (
	APIConfigurationKindAsyncsse       APIConfigurationKind = "async/sse"
	APIConfigurationKindAsyncwebsocket APIConfigurationKind = "async/websocket"
	APIConfigurationKindAsyncwebsub    APIConfigurationKind = "async/websub"
	APIConfigurationKindHttprest       APIConfigurationKind = "http/rest"
)

// Defines values for APIConfigurationVersion.
const (
	ApiPlatformWso2Comv1 APIConfigurationVersion = "api-platform.wso2.com/v1"
)

// Defines values for APIDetailResponseApiMetadataStatus.
const (
	APIDetailResponseApiMetadataStatusDeployed APIDetailResponseApiMetadataStatus = "deployed"
	APIDetailResponseApiMetadataStatusFailed   APIDetailResponseApiMetadataStatus = "failed"
	APIDetailResponseApiMetadataStatusPending  APIDetailResponseApiMetadataStatus = "pending"
)

// Defines values for APIListItemStatus.
const (
	APIListItemStatusDeployed APIListItemStatus = "deployed"
	APIListItemStatusFailed   APIListItemStatus = "failed"
	APIListItemStatusPending  APIListItemStatus = "pending"
)

// Defines values for CertificateResponseStatus.
const (
	Error   CertificateResponseStatus = "error"
	Success CertificateResponseStatus = "success"
)

// Defines values for ConfigDumpResponseApisMetadataStatus.
const (
	ConfigDumpResponseApisMetadataStatusDeployed ConfigDumpResponseApisMetadataStatus = "deployed"
	ConfigDumpResponseApisMetadataStatusFailed   ConfigDumpResponseApisMetadataStatus = "failed"
	ConfigDumpResponseApisMetadataStatusPending  ConfigDumpResponseApisMetadataStatus = "pending"
)

// Defines values for MCPDetailResponseMcpMetadataStatus.
const (
	MCPDetailResponseMcpMetadataStatusDeployed MCPDetailResponseMcpMetadataStatus = "deployed"
	MCPDetailResponseMcpMetadataStatusFailed   MCPDetailResponseMcpMetadataStatus = "failed"
	MCPDetailResponseMcpMetadataStatusPending  MCPDetailResponseMcpMetadataStatus = "pending"
)

// Defines values for MCPProxyConfigurationKind.
const (
	Mcp MCPProxyConfigurationKind = "mcp"
)

// Defines values for MCPProxyConfigurationVersion.
const (
	AiApiPlatformWso2Comv1 MCPProxyConfigurationVersion = "ai.api-platform.wso2.com/v1"
)

// Defines values for MCPProxyListItemStatus.
const (
	Deployed MCPProxyListItemStatus = "deployed"
	Failed   MCPProxyListItemStatus = "failed"
	Pending  MCPProxyListItemStatus = "pending"
)

// Defines values for OperationMethod.
const (
	DELETE  OperationMethod = "DELETE"
	GET     OperationMethod = "GET"
	HEAD    OperationMethod = "HEAD"
	OPTIONS OperationMethod = "OPTIONS"
	PATCH   OperationMethod = "PATCH"
	POST    OperationMethod = "POST"
	PUT     OperationMethod = "PUT"
)

// Defines values for ServerProtocol.
const (
	Kafka     ServerProtocol = "kafka"
	Mqtt      ServerProtocol = "mqtt"
	Sse       ServerProtocol = "sse"
	Websocket ServerProtocol = "websocket"
	Websub    ServerProtocol = "websub"
)

// Defines values for WebhookAPIDataApiType.
const (
	Asyncwebsub WebhookAPIDataApiType = "async/websub"
)

// APIConfigData defines model for APIConfigData.
type APIConfigData struct {
	// ApiType API type
	ApiType APIConfigDataApiType `json:"apiType" yaml:"apiType"`

	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context" yaml:"context"`

	// Name Human-readable API name (must be URL-friendly - only letters, numbers, spaces, hyphens, underscores, and dots allowed)
	Name string `json:"name" yaml:"name"`

	// Operations List of HTTP operations/routes
	Operations []Operation `json:"operations" yaml:"operations"`

	// Policies List of API-level policies applied to all operations unless overridden
	Policies *[]Policy `json:"policies,omitempty" yaml:"policies,omitempty"`

	// Upstreams List of backend service URLs
	Upstreams []Upstream `json:"upstreams" yaml:"upstreams"`

	// Version Semantic version of the API
	Version string `json:"version" yaml:"version"`
}

// APIConfigDataApiType API type
type APIConfigDataApiType string

// APIConfiguration defines model for APIConfiguration.
type APIConfiguration struct {
	// Kind API type
	Kind APIConfigurationKind `json:"kind" yaml:"kind"`

	// Spec API configuration payload (REST or Async API variants)
	Spec APIConfiguration_Spec `json:"spec" yaml:"spec"`

	// Version API specification version
	Version APIConfigurationVersion `json:"version" yaml:"version"`
}

// APIConfigurationKind API type
type APIConfigurationKind string

// APIConfiguration_Spec API configuration payload (REST or Async API variants)
type APIConfiguration_Spec struct {
	union json.RawMessage
}

// APIConfigurationVersion API specification version
type APIConfigurationVersion string

// APICreateResponse defines model for APICreateResponse.
type APICreateResponse struct {
	CreatedAt *time.Time `json:"created_at,omitempty" yaml:"created_at,omitempty"`

	// Id Unique identifier for the created API configuration
	Id      *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Message *string             `json:"message,omitempty" yaml:"message,omitempty"`
	Status  *string             `json:"status,omitempty" yaml:"status,omitempty"`
}

// APIDetailResponse defines model for APIDetailResponse.
type APIDetailResponse struct {
	Api *struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty" yaml:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty" yaml:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty" yaml:"deployed_at,omitempty"`
			Status     *APIDetailResponseApiMetadataStatus `json:"status,omitempty" yaml:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
		} `json:"metadata,omitempty" yaml:"metadata,omitempty"`
	} `json:"api,omitempty" yaml:"api,omitempty"`
	Status *string `json:"status,omitempty" yaml:"status,omitempty"`
}

// APIDetailResponseApiMetadataStatus defines model for APIDetailResponse.Api.Metadata.Status.
type APIDetailResponseApiMetadataStatus string

// APIListItem defines model for APIListItem.
type APIListItem struct {
	Context   *string             `json:"context,omitempty" yaml:"context,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty" yaml:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Name      *string             `json:"name,omitempty" yaml:"name,omitempty"`
	Status    *APIListItemStatus  `json:"status,omitempty" yaml:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
	Version   *string             `json:"version,omitempty" yaml:"version,omitempty"`
}

// APIListItemStatus defines model for APIListItem.Status.
type APIListItemStatus string

// APIUpdateResponse defines model for APIUpdateResponse.
type APIUpdateResponse struct {
	Id        *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Message   *string             `json:"message,omitempty" yaml:"message,omitempty"`
	Status    *string             `json:"status,omitempty" yaml:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
}

// CertificateListResponse defines model for CertificateListResponse.
type CertificateListResponse struct {
	Certificates *[]CertificateResponse `json:"certificates,omitempty" yaml:"certificates,omitempty"`
	Status       *string                `json:"status,omitempty" yaml:"status,omitempty"`

	// TotalBytes Total bytes of all certificate files
	TotalBytes *int `json:"totalBytes,omitempty" yaml:"totalBytes,omitempty"`

	// TotalCount Total number of certificate files
	TotalCount *int `json:"totalCount,omitempty" yaml:"totalCount,omitempty"`
}

// CertificateResponse defines model for CertificateResponse.
type CertificateResponse struct {
	// Count Number of certificates in the file
	Count *int `json:"count,omitempty" yaml:"count,omitempty"`

	// Id Unique identifier (UUID) for the certificate
	Id *string `json:"id,omitempty" yaml:"id,omitempty"`

	// Issuer Certificate issuer DN (for first cert if bundle)
	Issuer *string `json:"issuer,omitempty" yaml:"issuer,omitempty"`

	// Message Success or informational message
	Message *string `json:"message,omitempty" yaml:"message,omitempty"`

	// Name Name of the certificate
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`

	// NotAfter Certificate expiration date (for first cert if bundle)
	NotAfter *time.Time                 `json:"notAfter,omitempty" yaml:"notAfter,omitempty"`
	Status   *CertificateResponseStatus `json:"status,omitempty" yaml:"status,omitempty"`

	// Subject Certificate subject DN (for first cert if bundle)
	Subject *string `json:"subject,omitempty" yaml:"subject,omitempty"`
}

// CertificateResponseStatus defines model for CertificateResponse.Status.
type CertificateResponseStatus string

// CertificateUploadRequest defines model for CertificateUploadRequest.
type CertificateUploadRequest struct {
	// Certificate PEM-encoded X.509 certificate(s). Can contain multiple certificates.
	Certificate string `json:"certificate" yaml:"certificate"`

	// Name Unique name for the certificate. Must be unique across all certificates.
	Name string `json:"name" yaml:"name"`
}

// Channel Channel (topic/event stream) definition for async APIs.
type Channel struct {
	// Bindings Protocol-specific channel bindings (arbitrary key/value structure).
	Bindings *map[string]interface{} `json:"bindings,omitempty" yaml:"bindings,omitempty"`

	// Description Human-readable description of the channel.
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// Parameters Path/channel parameters (keyed by parameter name).
	Parameters *map[string]struct {
		Description *string `json:"description,omitempty" yaml:"description,omitempty"`

		// Schema JSON Schema fragment for the parameter value.
		Schema *map[string]interface{} `json:"schema,omitempty" yaml:"schema,omitempty"`
	} `json:"parameters,omitempty" yaml:"parameters,omitempty"`

	// Path Channel path or topic identifier relative to API context.
	Path string `json:"path" yaml:"path"`

	// Policies List of policies applied only to this operation (overrides or adds to API-level policies)
	Policies *[]Policy `json:"policies,omitempty" yaml:"policies,omitempty"`

	// Publish Producer (send) operation definition.
	Publish *struct {
		// Message Event/message definition transported over a channel.
		Message *ChannelMessage `json:"message,omitempty" yaml:"message,omitempty"`
		Summary *string         `json:"summary,omitempty" yaml:"summary,omitempty"`
	} `json:"publish,omitempty" yaml:"publish,omitempty"`

	// Subscribe Consumer (receive) operation definition.
	Subscribe *struct {
		// Message Event/message definition transported over a channel.
		Message *ChannelMessage `json:"message,omitempty" yaml:"message,omitempty"`
		Summary *string         `json:"summary,omitempty" yaml:"summary,omitempty"`
	} `json:"subscribe,omitempty" yaml:"subscribe,omitempty"`
}

// ChannelMessage Event/message definition transported over a channel.
type ChannelMessage struct {
	// ContentType Content type of the payload.
	ContentType *string `json:"content_type,omitempty" yaml:"content_type,omitempty"`

	// Name Logical message name.
	Name string `json:"name" yaml:"name"`

	// Payload JSON Schema representation of the message body.
	Payload map[string]interface{} `json:"payload" yaml:"payload"`

	// Summary Short description of the message.
	Summary *string `json:"summary,omitempty" yaml:"summary,omitempty"`
}

// ConfigDumpResponse defines model for ConfigDumpResponse.
type ConfigDumpResponse struct {
	// Apis All deployed API configurations
	Apis *[]struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty" yaml:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty" yaml:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                            `json:"created_at,omitempty" yaml:"created_at,omitempty"`
			DeployedAt *time.Time                            `json:"deployed_at,omitempty" yaml:"deployed_at,omitempty"`
			Status     *ConfigDumpResponseApisMetadataStatus `json:"status,omitempty" yaml:"status,omitempty"`
			UpdatedAt  *time.Time                            `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
		} `json:"metadata,omitempty" yaml:"metadata,omitempty"`
	} `json:"apis,omitempty" yaml:"apis,omitempty"`

	// Certificates All registered certificates
	Certificates *[]CertificateResponse `json:"certificates,omitempty" yaml:"certificates,omitempty"`

	// Policies All loaded policy definitions
	Policies *[]PolicyDefinition `json:"policies,omitempty" yaml:"policies,omitempty"`

	// Statistics Summary statistics about the current configuration
	Statistics *struct {
		// TotalApis Total number of API configurations
		TotalApis *int `json:"totalApis,omitempty" yaml:"totalApis,omitempty"`

		// TotalCertificateBytes Total bytes of all certificates
		TotalCertificateBytes *int `json:"totalCertificateBytes,omitempty" yaml:"totalCertificateBytes,omitempty"`

		// TotalCertificates Total number of certificates
		TotalCertificates *int `json:"totalCertificates,omitempty" yaml:"totalCertificates,omitempty"`

		// TotalPolicies Total number of policy definitions
		TotalPolicies *int `json:"totalPolicies,omitempty" yaml:"totalPolicies,omitempty"`
	} `json:"statistics,omitempty" yaml:"statistics,omitempty"`
	Status *string `json:"status,omitempty" yaml:"status,omitempty"`

	// Timestamp Timestamp when the config dump was generated
	Timestamp *time.Time `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

// ConfigDumpResponseApisMetadataStatus defines model for ConfigDumpResponse.Apis.Metadata.Status.
type ConfigDumpResponseApisMetadataStatus string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors Detailed validation errors
	Errors *[]ValidationError `json:"errors,omitempty" yaml:"errors,omitempty"`

	// Message High-level error description
	Message string `json:"message" yaml:"message"`
	Status  string `json:"status" yaml:"status"`
}

// MCPDetailResponse defines model for MCPDetailResponse.
type MCPDetailResponse struct {
	Mcp *struct {
		Configuration *MCPProxyConfiguration `json:"configuration,omitempty" yaml:"configuration,omitempty"`
		Id            *openapi_types.UUID    `json:"id,omitempty" yaml:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty" yaml:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty" yaml:"deployed_at,omitempty"`
			Status     *MCPDetailResponseMcpMetadataStatus `json:"status,omitempty" yaml:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
		} `json:"metadata,omitempty" yaml:"metadata,omitempty"`
	} `json:"mcp,omitempty" yaml:"mcp,omitempty"`
	Status *string `json:"status,omitempty" yaml:"status,omitempty"`
}

// MCPDetailResponseMcpMetadataStatus defines model for MCPDetailResponse.Mcp.Metadata.Status.
type MCPDetailResponseMcpMetadataStatus string

// MCPPrompt defines model for MCPPrompt.
type MCPPrompt struct {
	// Arguments Optional list of arguments for customization
	Arguments *[]struct {
		// Description Description of the argument
		Description *string `json:"description,omitempty" yaml:"description,omitempty"`

		// Name Name of the argument
		Name string `json:"name" yaml:"name"`

		// Required Whether the argument is required
		Required *bool `json:"required,omitempty" yaml:"required,omitempty"`

		// Title Optional human-readable title of the argument
		Title *string `json:"title,omitempty" yaml:"title,omitempty"`
	} `json:"arguments,omitempty" yaml:"arguments,omitempty"`

	// Description Optional human-readable description
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// Name Unique identifier for the prompt
	Name string `json:"name" yaml:"name"`

	// Title Optional human-readable name of the prompt for display purposes
	Title *string `json:"title,omitempty" yaml:"title,omitempty"`
}

// MCPProxyConfigData defines model for MCPProxyConfigData.
type MCPProxyConfigData struct {
	// Context MCP Proxy context path
	Context string `json:"context" yaml:"context"`

	// Name Human-readable MCP Proxy name
	Name      string         `json:"name" yaml:"name"`
	Prompts   *[]MCPPrompt   `json:"prompts,omitempty" yaml:"prompts,omitempty"`
	Resources *[]MCPResource `json:"resources,omitempty" yaml:"resources,omitempty"`

	// SpecVersion MCP specification version
	SpecVersion *string    `json:"specVersion,omitempty" yaml:"specVersion,omitempty"`
	Tools       *[]MCPTool `json:"tools,omitempty" yaml:"tools,omitempty"`

	// Upstreams List of backend service URLs
	Upstreams []Upstream `json:"upstreams" yaml:"upstreams"`

	// Version MCP Proxy version
	Version string `json:"version" yaml:"version"`
}

// MCPProxyConfiguration defines model for MCPProxyConfiguration.
type MCPProxyConfiguration struct {
	// Kind MCP Proxy type
	Kind MCPProxyConfigurationKind `json:"kind" yaml:"kind"`
	Spec MCPProxyConfigData        `json:"spec" yaml:"spec"`

	// Version MCP Proxy specification version
	Version MCPProxyConfigurationVersion `json:"version" yaml:"version"`
}

// MCPProxyConfigurationKind MCP Proxy type
type MCPProxyConfigurationKind string

// MCPProxyConfigurationVersion MCP Proxy specification version
type MCPProxyConfigurationVersion string

// MCPProxyListItem defines model for MCPProxyListItem.
type MCPProxyListItem struct {
	Context     *string                 `json:"context,omitempty" yaml:"context,omitempty"`
	CreatedAt   *time.Time              `json:"created_at,omitempty" yaml:"created_at,omitempty"`
	Id          *openapi_types.UUID     `json:"id,omitempty" yaml:"id,omitempty"`
	Name        *string                 `json:"name,omitempty" yaml:"name,omitempty"`
	SpecVersion *string                 `json:"specVersion,omitempty" yaml:"specVersion,omitempty"`
	Status      *MCPProxyListItemStatus `json:"status,omitempty" yaml:"status,omitempty"`
	UpdatedAt   *time.Time              `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
	Version     *string                 `json:"version,omitempty" yaml:"version,omitempty"`
}

// MCPProxyListItemStatus defines model for MCPProxyListItem.Status.
type MCPProxyListItemStatus string

// MCPResource defines model for MCPResource.
type MCPResource struct {
	// Description Optional description
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// MimeType Optional MIME type
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty"`

	// Name The name of the resource
	Name string `json:"name" yaml:"name"`

	// Size Optional size in bytes
	Size *int `json:"size,omitempty" yaml:"size,omitempty"`

	// Title Optional human-readable name of the resource for display purposes
	Title *string `json:"title,omitempty" yaml:"title,omitempty"`

	// Uri Unique identifier for the resource
	Uri string `json:"uri" yaml:"uri"`
}

// MCPTool defines model for MCPTool.
type MCPTool struct {
	// Description Human-readable description of functionality
	Description string `json:"description" yaml:"description"`

	// InputSchema JSON Schema defining expected parameters
	InputSchema string `json:"inputSchema" yaml:"inputSchema"`

	// Name Unique identifier for the tool
	Name string `json:"name" yaml:"name"`

	// OutputSchema Optional JSON Schema defining expected output structure
	OutputSchema *string `json:"outputSchema,omitempty" yaml:"outputSchema,omitempty"`

	// Title Optional human-readable name of the tool for display purposes.
	Title *string `json:"title,omitempty" yaml:"title,omitempty"`
}

// Operation defines model for Operation.
type Operation struct {
	// Method HTTP method
	Method OperationMethod `json:"method" yaml:"method"`

	// Path Route path with optional {param} placeholders
	Path string `json:"path" yaml:"path"`

	// Policies List of policies applied only to this operation (overrides or adds to API-level policies)
	Policies *[]Policy `json:"policies,omitempty" yaml:"policies,omitempty"`
}

// OperationMethod HTTP method
type OperationMethod string

// Policy defines model for Policy.
type Policy struct {
	// ExecutionCondition Expression controlling conditional execution of the policy
	ExecutionCondition *string `json:"executionCondition,omitempty" yaml:"executionCondition,omitempty"`

	// Name Name of the policy
	Name string `json:"name" yaml:"name"`

	// Params Arbitrary parameters for the policy (free-form key/value structure)
	Params *map[string]interface{} `json:"params,omitempty" yaml:"params,omitempty"`

	// Version Semantic version of the policy
	Version string `json:"version" yaml:"version"`
}

// PolicyDefinition defines model for PolicyDefinition.
type PolicyDefinition struct {
	// Description Human readable description of the policy's purpose
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// Name Unique policy name
	Name string `json:"name" yaml:"name"`

	// ParametersSchema JSON Schema describing the parameters accepted by this policy. This itself is a JSON Schema document.
	ParametersSchema *map[string]interface{} `json:"parametersSchema,omitempty" yaml:"parametersSchema,omitempty"`

	// Version Semantic version of the policy definition
	Version string `json:"version" yaml:"version"`
}

// PolicyListResponse defines model for PolicyListResponse.
type PolicyListResponse struct {
	Count    *int                `json:"count,omitempty" yaml:"count,omitempty"`
	Policies *[]PolicyDefinition `json:"policies,omitempty" yaml:"policies,omitempty"`
	Status   *string             `json:"status,omitempty" yaml:"status,omitempty"`
}

// Server Server definition for async or WebSub APIs.
type Server struct {
	// Bindings Protocol-specific server bindings (arbitrary key/value structure).
	Bindings *map[string]interface{} `json:"bindings,omitempty" yaml:"bindings,omitempty"`

	// Description Human-readable description of this server.
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// Protocol Transport protocol used by the server.
	Protocol ServerProtocol `json:"protocol" yaml:"protocol"`

	// ProtocolVersion Version of the selected protocol (if applicable).
	ProtocolVersion *string `json:"protocolVersion,omitempty" yaml:"protocolVersion,omitempty"`

	// Security Security requirements for this server (each item maps scheme name to optional scopes array).
	Security *[]map[string][]string `json:"security,omitempty" yaml:"security,omitempty"`

	// Url Base URL or connection string for the server (variables may be denoted by {name}).
	Url string `json:"url" yaml:"url"`

	// Variables Templated variables contained in the server URL.
	Variables *map[string]struct {
		// Default Default value for the variable.
		Default string `json:"default" yaml:"default"`

		// Description Description of the variable.
		Description *string `json:"description,omitempty" yaml:"description,omitempty"`

		// Enum Allowed values.
		Enum *[]string `json:"enum,omitempty" yaml:"enum,omitempty"`
	} `json:"variables,omitempty" yaml:"variables,omitempty"`
}

// ServerProtocol Transport protocol used by the server.
type ServerProtocol string

// Upstream defines model for Upstream.
type Upstream struct {
	// Url Backend service URL (may include path prefix like /api/v2)
	Url string `json:"url" yaml:"url"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field that failed validation
	Field *string `json:"field,omitempty" yaml:"field,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty" yaml:"message,omitempty"`
}

// WebhookAPIData defines model for WebhookAPIData.
type WebhookAPIData struct {
	// ApiType API type
	ApiType WebhookAPIDataApiType `json:"apiType" yaml:"apiType"`

	// Channels List of operations - HTTP operations for REST APIs or event/topic operations for async APIs
	Channels []Channel `json:"channels" yaml:"channels"`

	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context" yaml:"context"`

	// Name Human-readable API name (must be URL-friendly - only letters, numbers, spaces, hyphens, underscores, and dots allowed)
	Name string `json:"name" yaml:"name"`

	// Policies List of API-level policies applied to all operations unless overridden
	Policies *[]Policy `json:"policies,omitempty" yaml:"policies,omitempty"`

	// Servers List of backend service URLs (for REST APIs) or event hub URLs (for async APIs)
	Servers []Server `json:"servers" yaml:"servers"`

	// Version Semantic version of the API
	Version string `json:"version" yaml:"version"`
}

// WebhookAPIDataApiType API type
type WebhookAPIDataApiType string

// CreateAPIJSONRequestBody defines body for CreateAPI for application/json ContentType.
type CreateAPIJSONRequestBody = APIConfiguration

// UpdateAPIJSONRequestBody defines body for UpdateAPI for application/json ContentType.
type UpdateAPIJSONRequestBody = APIConfiguration

// UploadCertificateJSONRequestBody defines body for UploadCertificate for application/json ContentType.
type UploadCertificateJSONRequestBody = CertificateUploadRequest

// CreateMCPProxyJSONRequestBody defines body for CreateMCPProxy for application/json ContentType.
type CreateMCPProxyJSONRequestBody = MCPProxyConfiguration

// UpdateMCPProxyJSONRequestBody defines body for UpdateMCPProxy for application/json ContentType.
type UpdateMCPProxyJSONRequestBody = MCPProxyConfiguration

// AsAPIConfigData returns the union data inside the APIConfiguration_Spec as a APIConfigData
func (t APIConfiguration_Spec) AsAPIConfigData() (APIConfigData, error) {
	var body APIConfigData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAPIConfigData overwrites any union data inside the APIConfiguration_Spec as the provided APIConfigData
func (t *APIConfiguration_Spec) FromAPIConfigData(v APIConfigData) error {
	v.ApiType = "http/rest"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAPIConfigData performs a merge with any union data inside the APIConfiguration_Spec, using the provided APIConfigData
func (t *APIConfiguration_Spec) MergeAPIConfigData(v APIConfigData) error {
	v.ApiType = "http/rest"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookAPIData returns the union data inside the APIConfiguration_Spec as a WebhookAPIData
func (t APIConfiguration_Spec) AsWebhookAPIData() (WebhookAPIData, error) {
	var body WebhookAPIData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookAPIData overwrites any union data inside the APIConfiguration_Spec as the provided WebhookAPIData
func (t *APIConfiguration_Spec) FromWebhookAPIData(v WebhookAPIData) error {
	v.ApiType = "async/websocket"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookAPIData performs a merge with any union data inside the APIConfiguration_Spec, using the provided WebhookAPIData
func (t *APIConfiguration_Spec) MergeWebhookAPIData(v WebhookAPIData) error {
	v.ApiType = "async/websocket"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t APIConfiguration_Spec) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"apiType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t APIConfiguration_Spec) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "async/websocket":
		return t.AsWebhookAPIData()
	case "http/rest":
		return t.AsAPIConfigData()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t APIConfiguration_Spec) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *APIConfiguration_Spec) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all API configurations
	// (GET /apis)
	ListAPIs(c *gin.Context)
	// Create a new API configuration
	// (POST /apis)
	CreateAPI(c *gin.Context)
	// Delete an API configuration
	// (DELETE /apis/{name}/{version})
	DeleteAPI(c *gin.Context, name string, version string)
	// Get API configuration by name and version
	// (GET /apis/{name}/{version})
	GetAPIByNameVersion(c *gin.Context, name string, version string)
	// Update an existing API configuration
	// (PUT /apis/{name}/{version})
	UpdateAPI(c *gin.Context, name string, version string)
	// List all custom certificates
	// (GET /certificates)
	ListCertificates(c *gin.Context)
	// Upload a new certificate
	// (POST /certificates)
	UploadCertificate(c *gin.Context)
	// Manually reload certificates
	// (POST /certificates/reload)
	ReloadCertificates(c *gin.Context)
	// Delete a certificate
	// (DELETE /certificates/{id})
	DeleteCertificate(c *gin.Context, id string)
	// Dump current configuration state
	// (GET /config_dump)
	GetConfigDump(c *gin.Context)
	// Health check endpoint
	// (GET /health)
	HealthCheck(c *gin.Context)
	// List all MCP Proxy configurations
	// (GET /mcp-proxies)
	ListMCPProxies(c *gin.Context)
	// Create a new MCP Proxy configuration
	// (POST /mcp-proxies)
	CreateMCPProxy(c *gin.Context)
	// Delete an MCP Proxy configuration
	// (DELETE /mcp-proxies/{name}/{version})
	DeleteMCPProxy(c *gin.Context, name string, version string)
	// Get MCP Proxy configuration by name and version
	// (GET /mcp-proxies/{name}/{version})
	GetMCPProxyByNameVersion(c *gin.Context, name string, version string)
	// Update an existing MCP Proxy configuration
	// (PUT /mcp-proxies/{name}/{version})
	UpdateMCPProxy(c *gin.Context, name string, version string)
	// List all registered policy definitions
	// (GET /policies)
	ListPolicies(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListAPIs operation middleware
func (siw *ServerInterfaceWrapper) ListAPIs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAPIs(c)
}

// CreateAPI operation middleware
func (siw *ServerInterfaceWrapper) CreateAPI(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateAPI(c)
}

// DeleteAPI operation middleware
func (siw *ServerInterfaceWrapper) DeleteAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAPI(c, name, version)
}

// GetAPIByNameVersion operation middleware
func (siw *ServerInterfaceWrapper) GetAPIByNameVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAPIByNameVersion(c, name, version)
}

// UpdateAPI operation middleware
func (siw *ServerInterfaceWrapper) UpdateAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateAPI(c, name, version)
}

// ListCertificates operation middleware
func (siw *ServerInterfaceWrapper) ListCertificates(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListCertificates(c)
}

// UploadCertificate operation middleware
func (siw *ServerInterfaceWrapper) UploadCertificate(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadCertificate(c)
}

// ReloadCertificates operation middleware
func (siw *ServerInterfaceWrapper) ReloadCertificates(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ReloadCertificates(c)
}

// DeleteCertificate operation middleware
func (siw *ServerInterfaceWrapper) DeleteCertificate(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteCertificate(c, id)
}

// GetConfigDump operation middleware
func (siw *ServerInterfaceWrapper) GetConfigDump(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConfigDump(c)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HealthCheck(c)
}

// ListMCPProxies operation middleware
func (siw *ServerInterfaceWrapper) ListMCPProxies(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListMCPProxies(c)
}

// CreateMCPProxy operation middleware
func (siw *ServerInterfaceWrapper) CreateMCPProxy(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateMCPProxy(c)
}

// DeleteMCPProxy operation middleware
func (siw *ServerInterfaceWrapper) DeleteMCPProxy(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteMCPProxy(c, name, version)
}

// GetMCPProxyByNameVersion operation middleware
func (siw *ServerInterfaceWrapper) GetMCPProxyByNameVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMCPProxyByNameVersion(c, name, version)
}

// UpdateMCPProxy operation middleware
func (siw *ServerInterfaceWrapper) UpdateMCPProxy(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateMCPProxy(c, name, version)
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPolicies(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/apis", wrapper.ListAPIs)
	router.POST(options.BaseURL+"/apis", wrapper.CreateAPI)
	router.DELETE(options.BaseURL+"/apis/:name/:version", wrapper.DeleteAPI)
	router.GET(options.BaseURL+"/apis/:name/:version", wrapper.GetAPIByNameVersion)
	router.PUT(options.BaseURL+"/apis/:name/:version", wrapper.UpdateAPI)
	router.GET(options.BaseURL+"/certificates", wrapper.ListCertificates)
	router.POST(options.BaseURL+"/certificates", wrapper.UploadCertificate)
	router.POST(options.BaseURL+"/certificates/reload", wrapper.ReloadCertificates)
	router.DELETE(options.BaseURL+"/certificates/:id", wrapper.DeleteCertificate)
	router.GET(options.BaseURL+"/config_dump", wrapper.GetConfigDump)
	router.GET(options.BaseURL+"/health", wrapper.HealthCheck)
	router.GET(options.BaseURL+"/mcp-proxies", wrapper.ListMCPProxies)
	router.POST(options.BaseURL+"/mcp-proxies", wrapper.CreateMCPProxy)
	router.DELETE(options.BaseURL+"/mcp-proxies/:name/:version", wrapper.DeleteMCPProxy)
	router.GET(options.BaseURL+"/mcp-proxies/:name/:version", wrapper.GetMCPProxyByNameVersion)
	router.PUT(options.BaseURL+"/mcp-proxies/:name/:version", wrapper.UpdateMCPProxy)
	router.GET(options.BaseURL+"/policies", wrapper.ListPolicies)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"QD5WQ+LBzfnN/wcAAP//6gKPkVCfAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
